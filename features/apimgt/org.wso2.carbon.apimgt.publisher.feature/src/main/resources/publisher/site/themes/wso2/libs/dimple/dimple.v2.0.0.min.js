var dimple = {
    version: "2.0.0",
    plot: {},
    aggregateMethod: {}
};
! function() {
    "use strict";
    dimple.axis = function(a, b, c, d, e) {
        this.chart = a, this.position = b, this.categoryFields = null === e || void 0 === e ? c : [].concat(e), this.measure = d, this.timeField = e, this.floatingBarWidth = 5, this.hidden = !1, this.showPercent = !1, this.colors = null, this.overrideMin = null, this.overrideMax = null, this.shapes = null, this.showGridlines = null, this.gridlineShapes = null, this.titleShape = null, this.dateParseFormat = null, this.tickFormat = null, this.timePeriod = null, this.timeInterval = 1, this.useLog = !1, this.logBase = 10, this.title = void 0, this.clamp = !0, this.ticks = null, this.fontSize = "10px", this.fontFamily = "sans-serif", this._slaves = [], this._scale = null, this._min = 0, this._max = 0, this._previousOrigin = null, this._origin = null, this._orderRules = [], this._groupOrderRules = [], this._draw = null, this._getAxisData = function() {
            var a, b, c = [],
                d = !1;
            if (this.chart && this.chart.series) {
                for (a = 0; a < this.chart.series.length; a += 1) b = this.chart.series[a], b[this.position] === this && (b.data && b.data.length > 0 ? c = c.concat(b.data) : d = !0);
                d && this.chart.data && (c = c.concat(this.chart.data))
            }
            return c
        }, this._getFontSize = function() {
            var a;
            return a = this.fontSize && "auto" !== this.fontSize.toString().toLowerCase() ? isNaN(this.fontSize) ? this.fontSize : this.fontSize + "px" : (this.chart._heightPixels() / 35 > 10 ? this.chart._heightPixels() / 35 : 10) + "px"
        }, this._getFormat = function() {
            var a, b, c, d, e, f, g;
            return null !== this.tickFormat && void 0 !== this.tickFormat ? a = this._hasTimeField() ? d3.time.format(this.tickFormat) : d3.format(this.tickFormat) : this.showPercent ? a = d3.format("%") : this.useLog && null !== this.measure ? a = function(a) {
                var b = Math.floor(Math.abs(a), 0).toString().length,
                    c = Math.min(Math.floor((b - 1) / 3), 4),
                    d = "kmBT".substring(c - 1, c),
                    e = "0" === Math.round(10 * (a / Math.pow(1e3, c))).toString().slice(-1) ? 0 : 1;
                return 0 === a ? 0 : d3.format(",." + e + "f")(a / Math.pow(1e3, c)) + d
            } : null !== this.measure ? (b = Math.floor(Math.abs(this._max), 0).toString(), c = Math.floor(Math.abs(this._min), 0).toString(), d = Math.max(c.length, b.length), d > 3 ? (e = Math.min(Math.floor((d - 1) / 3), 4), f = "kmBT".substring(e - 1, e), g = 1 >= d - 3 * e ? 1 : 0, a = function(a) {
                return 0 === a ? 0 : d3.format(",." + g + "f")(a / Math.pow(1e3, e)) + f
            }) : (g = 1 >= d ? 1 : 0, a = d3.format(",." + g + "f"))) : a = function(a) {
                return a
            }, a
        }, this._getTimePeriod = function() {
            var a = this.timePeriod,
                b = 30,
                c = this._max - this._min;
            return this._hasTimeField() && !this.timePeriod && (a = b >= c / 1e3 ? d3.time.seconds : b >= c / 6e4 ? d3.time.minutes : b >= c / 36e5 ? d3.time.hours : b >= c / 864e5 ? d3.time.days : b >= c / 6048e5 ? d3.time.weeks : b >= c / 26298e5 ? d3.time.months : d3.time.years), a
        }, this._getTooltipText = function(a, b) {
            if (this._hasTimeField()) b[this.position + "Field"][0] && a.push(this.timeField + ": " + this._getFormat()(b[this.position + "Field"][0]));
            else if (this._hasCategories()) this.categoryFields.forEach(function(c, d) {
                null !== c && void 0 !== c && b[this.position + "Field"][d] && a.push(c + (b[this.position + "Field"][d] !== c ? ": " + b[this.position + "Field"][d] : ""))
            }, this);
            else if (this._hasMeasure()) switch (this.position) {
                case "x":
                    a.push(this.measure + ": " + this._getFormat()(b.width));
                    break;
                case "y":
                    a.push(this.measure + ": " + this._getFormat()(b.height));
                    break;
                case "z":
                    a.push(this.measure + ": " + this._getFormat()(b.zValue));
                    break;
                case "c":
                    a.push(this.measure + ": " + this._getFormat()(b.cValue))
            }
        }, this._getTopMaster = function() {
            var a = this;
            return null !== this.master && void 0 !== this.master && (a = this.master._getTopMaster()), a
        }, this._hasCategories = function() {
            return null !== this.categoryFields && void 0 !== this.categoryFields && this.categoryFields.length > 0
        }, this._hasMeasure = function() {
            return null !== this.measure && void 0 !== this.measure
        }, this._hasTimeField = function() {
            return null !== this.timeField && void 0 !== this.timeField
        }, this._parseDate = function(a) {
            var b;
            return b = null === this.dateParseFormat || void 0 === this.dateParseFormat ? isNaN(a) ? Date.parse(a) : new Date(a) : d3.time.format(this.dateParseFormat).parse(a)
        }, this._update = function(a) {
            var b, c, d, e, f = [],
                g = this.ticks || 10,
                h = function(a, b, c) {
                    var d, e, f = a.categoryFields[0],
                        g = a._getAxisData(),
                        h = f,
                        i = !1,
                        j = !0,
                        k = null;
                    for (d = 0; d < g.length; d += 1)
                        if (k = a._parseDate(g[d][f]), null !== k && void 0 !== k && isNaN(k)) {
                            j = !1;
                            break
                        }
                    return j || a.chart.series.forEach(function(d) {
                        d[b] === a && d[c]._hasMeasure() && (h = d[c].measure, i = !0)
                    }, this), e = a._orderRules.concat({
                        ordering: h,
                        desc: i
                    }), dimple._getOrderedList(g, f, e)
                };
            if (this._min = this.showPercent && this._min < -1 ? -1 : this._min, this._max = this.showPercent && this._max > 1 ? 1 : this._max, this._min = null !== this.overrideMin ? this.overrideMin : this._min, this._max = null !== this.overrideMax ? this.overrideMax : this._max, "x" !== this.position || null !== this._scale && !a) {
                if ("y" !== this.position || null !== this._scale && !a) this.position.length > 0 && "z" === this.position[0] && null === this._scale ? this._scale = this.useLog ? d3.scale.log().range([this.chart._heightPixels() / 300, this.chart._heightPixels() / 10]).domain([0 === this._min ? Math.pow(this.logBase, -1) : this._min, 0 === this._max ? -1 * Math.pow(this.logBase, -1) : this._max]).clamp(this.clamp).base(this.logBase) : d3.scale.linear().range([this.chart._heightPixels() / 300, this.chart._heightPixels() / 10]).domain([this._min, this._max]).clamp(this.clamp) : this.position.length > 0 && "c" === this.position[0] && null === this._scale && (this._scale = d3.scale.linear().range([0, null === this.colors || 1 === this.colors.length ? 1 : this.colors.length - 1]).domain([this._min, this._max]).clamp(this.clamp));
                else if (this._hasTimeField() ? this._scale = d3.time.scale().rangeRound([this.chart._yPixels() + this.chart._heightPixels(), this.chart._yPixels()]).domain([this._min, this._max]).clamp(this.clamp) : this.useLog ? this._scale = d3.scale.log().range([this.chart._yPixels() + this.chart._heightPixels(), this.chart._yPixels()]).domain([0 === this._min ? Math.pow(this.logBase, -1) : this._min, 0 === this._max ? -1 * Math.pow(this.logBase, -1) : this._max]).clamp(this.clamp).base(this.logBase).nice() : null === this.measure || void 0 === this.measure ? (f = h(this, "y", "x"), null !== this._slaves && void 0 !== this._slaves && this._slaves.forEach(function(a) {
                        f = f.concat(h(a, "y", "x"))
                    }, this), this._scale = d3.scale.ordinal().rangePoints([this.chart._yPixels() + this.chart._heightPixels(), this.chart._yPixels()]).domain(f.concat([""]))) : this._scale = d3.scale.linear().range([this.chart._yPixels() + this.chart._heightPixels(), this.chart._yPixels()]).domain([this._min, this._max]).clamp(this.clamp).nice(), !this.hidden) switch (this.chart._axisIndex(this, "y")) {
                    case 0:
                        this._draw = d3.svg.axis().orient("left").scale(this._scale), this.ticks && this._draw.ticks(g);
                        break;
                    case 1:
                        this._draw = d3.svg.axis().orient("right").scale(this._scale), this.ticks && this._draw.ticks(g)
                }
            } else if (this._hasTimeField() ? this._scale = d3.time.scale().rangeRound([this.chart._xPixels(), this.chart._xPixels() + this.chart._widthPixels()]).domain([this._min, this._max]).clamp(this.clamp) : this.useLog ? this._scale = d3.scale.log().range([this.chart._xPixels(), this.chart._xPixels() + this.chart._widthPixels()]).domain([0 === this._min ? Math.pow(this.logBase, -1) : this._min, 0 === this._max ? -1 * Math.pow(this.logBase, -1) : this._max]).clamp(this.clamp).base(this.logBase).nice() : null === this.measure || void 0 === this.measure ? (f = h(this, "x", "y"), null !== this._slaves && void 0 !== this._slaves && this._slaves.forEach(function(a) {
                    f = f.concat(h(a, "x", "y"))
                }, this), this._scale = d3.scale.ordinal().rangePoints([this.chart._xPixels(), this.chart._xPixels() + this.chart._widthPixels()]).domain(f.concat([""]))) : this._scale = d3.scale.linear().range([this.chart._xPixels(), this.chart._xPixels() + this.chart._widthPixels()]).domain([this._min, this._max]).clamp(this.clamp).nice(), !this.hidden) switch (this.chart._axisIndex(this, "x")) {
                case 0:
                    this._draw = d3.svg.axis().orient("bottom").scale(this._scale), this.ticks && this._draw.ticks(g);
                    break;
                case 1:
                    this._draw = d3.svg.axis().orient("top").scale(this._scale), this.ticks && this._draw.ticks(g)
            }
            return null !== this._slaves && void 0 !== this._slaves && this._slaves.length > 0 && this._slaves.forEach(function(a) {
                a._scale = this._scale
            }, this), null !== a && void 0 !== a && a !== !1 || this._hasTimeField() || null === this._scale || null === this._scale.ticks || void 0 === this._scale.ticks || !(this._scale.ticks(g).length > 0) || "x" !== this.position && "y" !== this.position || (b = this._scale.ticks(g), c = b[1] - b[0], d = ((this._max - this._min) % c).toFixed(0), 0 !== d && (this._max = Math.ceil(this._max / c) * c, this._min = Math.floor(this._min / c) * c, this._update(!0))), e = null !== f && void 0 !== f && f.length > 0 ? this._scale.copy()(f[0]) : this._min > 0 ? this._scale.copy()(this._min) : this._max < 0 ? this._scale.copy()(this._max) : this._scale.copy()(0), this._origin !== e && (this._previousOrigin = null === this._origin ? e : this._origin, this._origin = e), this
        }, this.addGroupOrderRule = function(a, b) {
            this._groupOrderRules.push({
                ordering: a,
                desc: b
            })
        }, this.addOrderRule = function(a, b) {
            this._orderRules.push({
                ordering: a,
                desc: b
            })
        }
    }, dimple.chart = function(a, b) {
        this.svg = a, this.x = "10%", this.y = "10%", this.width = "80%", this.height = "80%", this.data = b, this.noFormats = !1, this.axes = [], this.series = [], this.legends = [], this.storyboard = null, this.titleShape = null, this.shapes = null, this.ease = "cubic-in-out", this.staggerDraw = !1, this._group = a.append("g"), this._tooltipGroup = null, this._assignedColors = {}, this._nextColor = 0, this._axisIndex = function(a, b) {
            var c = 0,
                d = 0,
                e = -1;
            for (c = 0; c < this.axes.length; c += 1) {
                if (this.axes[c] === a) {
                    e = d;
                    break
                }(null === b || void 0 === b || b[0] === this.axes[c].position[0]) && (d += 1)
            }
            return e
        }, this._getAllData = function() {
            var a = [];
            return null !== this.data && void 0 !== this.data && this.data.length > 0 && (a = a.concat(this.data)), null !== this.series && void 0 !== this.series && this.series.length > 0 && this.series.forEach(function(b) {
                null !== b.data && void 0 !== b.data && b.data.length > 0 && (a = a.concat(b.data))
            }), a
        }, this._getDelay = function(a, b, c) {
            return function(d) {
                var e = 0;
                return c && b.staggerDraw && (c.x._hasCategories() ? e = dimple._helpers.cx(d, b, c) / b._widthPixels() * a : c.y._hasCategories() && (e = (1 - dimple._helpers.cy(d, b, c) / b._heightPixels()) * a)), e
            }
        }, this._getSeriesData = function() {
            null !== this.series && void 0 !== this.series && this.series.forEach(function(a) {
                var b, c, d = [],
                    e = function(a, b) {
                        var c = [];
                        return null !== a && (a._hasTimeField() ? c.push(a._parseDate(b[a.timeField])) : a._hasCategories() && a.categoryFields.forEach(function(a) {
                            c.push(b[a])
                        }, this)), c
                    },
                    f = {
                        x: !1,
                        y: !1,
                        z: !1,
                        c: !1
                    },
                    g = {
                        x: [],
                        y: []
                    },
                    h = {
                        x: [],
                        y: [],
                        z: []
                    },
                    i = {
                        min: null,
                        max: null
                    },
                    j = {
                        x: [],
                        y: [],
                        z: []
                    },
                    k = [],
                    l = {},
                    m = {
                        x: 0,
                        y: 0,
                        z: 0
                    },
                    n = "",
                    o = [],
                    p = [],
                    q = [],
                    r = "",
                    s = [],
                    t = "",
                    u = [],
                    v = [],
                    w = a.data || this.data || [],
                    x = [];
                null !== this.storyboard && void 0 !== this.storyboard && this.storyboard.categoryFields.length > 0 && (n = this.storyboard.categoryFields[0], o = dimple._getOrderedList(w, n, this.storyboard._orderRules)), a.x._hasCategories() && a.x._hasMeasure() && (r = a.x.categoryFields[0], s = dimple._getOrderedList(w, r, a.x._orderRules.concat([{
                    ordering: a.x.measure,
                    desc: !0
                }]))), a.y._hasCategories() && a.y._hasMeasure() && (t = a.y.categoryFields[0], u = dimple._getOrderedList(w, t, a.y._orderRules.concat([{
                    ordering: a.y.measure,
                    desc: !0
                }]))), w.length > 0 && null !== a.categoryFields && void 0 !== a.categoryFields && a.categoryFields.length > 0 && (v = [].concat(a._orderRules), p = [], a.categoryFields.forEach(function(a) {
                    void 0 !== w[0][a] && p.push(a)
                }, this), null !== a.c && void 0 !== a.c && a.c._hasMeasure() ? v.push({
                    ordering: a.c.measure,
                    desc: !0
                }) : null !== a.z && void 0 !== a.z && a.z._hasMeasure() ? v.push({
                    ordering: a.z.measure,
                    desc: !0
                }) : a.x._hasMeasure() ? v.push({
                    ordering: a.x.measure,
                    desc: !0
                }) : a.y._hasMeasure() && v.push({
                    ordering: a.y.measure,
                    desc: !0
                }), q = dimple._getOrderedList(w, p, v)), w.sort(function(a, b) {
                    var c, d, e, f, g, h, i = 0;
                    if ("" !== n && (i = o.indexOf(a[n]) - o.indexOf(b[n])), "" !== r && 0 === i && (i = s.indexOf(a[r]) - s.indexOf(b[r])), "" !== t && 0 === i && (i = u.indexOf(a[t]) - u.indexOf(b[t])), p && p.length > 0 && 0 === i)
                        for (c = [].concat(p), i = 0, e = 0; e < q.length; e += 1) {
                            for (d = [].concat(q[e]), g = !0, h = !0, f = 0; f < c.length; f += 1) g = g && a[c[f]] === d[f], h = h && b[c[f]] === d[f];
                            if (g && h) {
                                i = 0;
                                break
                            }
                            if (g) {
                                i = -1;
                                break
                            }
                            if (h) {
                                i = 1;
                                break
                            }
                        }
                    return i
                }), w.forEach(function(b) {
                    var c, g, h, i, j, k = -1,
                        l = e(a.x, b),
                        m = e(a.y, b),
                        n = e(a.z, b),
                        o = [];
                    if (null === a.categoryFields || void 0 === a.categoryFields || 0 === a.categoryFields.length) o = ["All"];
                    else
                        for (h = 0; h < a.categoryFields.length; h += 1) void 0 === b[a.categoryFields[h]] ? o.push(a.categoryFields[h]) : o.push(b[a.categoryFields[h]]);
                    for (c = o.join("/") + "_" + l.join("/") + "_" + m.join("/") + "_" + n.join("/"), g = 0; g < d.length; g += 1)
                        if (d[g].key === c) {
                            k = g;
                            break
                        } - 1 === k && (i = {
                        key: c,
                        aggField: o,
                        xField: l,
                        xValue: null,
                        xCount: 0,
                        yField: m,
                        yValue: null,
                        yCount: 0,
                        zField: n,
                        zValue: null,
                        zCount: 0,
                        cValue: 0,
                        cCount: 0,
                        x: 0,
                        y: 0,
                        xOffset: 0,
                        yOffset: 0,
                        width: 0,
                        height: 0,
                        cx: 0,
                        cy: 0,
                        xBound: 0,
                        yBound: 0,
                        xValueList: [],
                        yValueList: [],
                        zValueList: [],
                        cValueList: [],
                        fill: {},
                        stroke: {}
                    }, d.push(i), k = d.length - 1), j = function(c, e) {
                        var g, h, i = !0,
                            j = {
                                value: 0,
                                count: 1
                            },
                            l = {
                                value: 0,
                                count: 1
                            },
                            m = "";
                        null !== e && (g = e.getFrameValue(), e.categoryFields.forEach(function(a, c) {
                            c > 0 && (m += "/"), m += b[a], i = m === g
                        }, this)), null !== c && void 0 !== c && i && (h = d[k], c._hasMeasure() && null !== b[c.measure] && void 0 !== b[c.measure] && (-1 === h[c.position + "ValueList"].indexOf(b[c.measure]) && h[c.position + "ValueList"].push(b[c.measure]), isNaN(parseFloat(b[c.measure])) && (f[c.position] = !0), j.value = h[c.position + "Value"], j.count = h[c.position + "Count"], l.value = b[c.measure], h[c.position + "Value"] = a.aggregate(j, l), h[c.position + "Count"] += 1))
                    }, j(a.x, this.storyboard), j(a.y, this.storyboard), j(a.z, this.storyboard), j(a.c, this.storyboard)
                }, this), null !== a.x && void 0 !== a.x && a.x._hasCategories() && a.x.categoryFields.length > 1 && void 0 !== g.x && (x = [], a.y._hasMeasure() && x.push({
                    ordering: a.y.measure,
                    desc: !0
                }), g.x = dimple._getOrderedList(w, a.x.categoryFields[1], a.x._groupOrderRules.concat(x))), null !== a.y && void 0 !== a.y && a.y._hasCategories() && a.y.categoryFields.length > 1 && void 0 !== g.y && (x = [], a.x._hasMeasure() && x.push({
                    ordering: a.x.measure,
                    desc: !0
                }), g.y = dimple._getOrderedList(w, a.y.categoryFields[1], a.y._groupOrderRules.concat(x)), g.y.reverse()), d.forEach(function(c) {
                    null !== a.x && (f.x === !0 && (c.xValue = c.xValueList.length), b = (null === h.x[c.xField.join("/")] || void 0 === h.x[c.xField.join("/")] ? 0 : h.x[c.xField.join("/")]) + (a.y._hasMeasure() ? Math.abs(c.yValue) : 0), h.x[c.xField.join("/")] = b), null !== a.y && (f.y === !0 && (c.yValue = c.yValueList.length), b = (null === h.y[c.yField.join("/")] || void 0 === h.y[c.yField.join("/")] ? 0 : h.y[c.yField.join("/")]) + (a.x._hasMeasure() ? Math.abs(c.xValue) : 0), h.y[c.yField.join("/")] = b), null !== a.z && (f.z === !0 && (c.zValue = c.zValueList.length), b = (null === h.z[c.zField.join("/")] || void 0 === h.z[c.zField.join("/")] ? 0 : h.z[c.zField.join("/")]) + (a.z._hasMeasure() ? Math.abs(c.zValue) : 0), h.z[c.zField.join("/")] = b), null !== a.c && ((null === i.min || c.cValue < i.min) && (i.min = c.cValue), (null === i.max || c.cValue > i.max) && (i.max = c.cValue))
                }, this);
                for (c in h.x) h.x.hasOwnProperty(c) && (m.x += h.x[c]);
                for (c in h.y) h.y.hasOwnProperty(c) && (m.y += h.y[c]);
                for (c in h.z) h.z.hasOwnProperty(c) && (m.z += h.z[c]);
                d.forEach(function(b) {
                    var c, d, e, f, n, o = function(c, d, e) {
                        var f, i, n, o, p;
                        null !== c && void 0 !== c && (o = c.position, c._hasCategories() ? c._hasMeasure() ? (f = b[c.position + "Field"].join("/"), i = c.showPercent ? h[c.position][f] / m[c.position] : h[c.position][f], -1 === k.indexOf(f) && (l[f] = i + (k.length > 0 ? l[k[k.length - 1]] : 0), k.push(f)), n = b[o + "Bound"] = b["c" + o] = "x" !== o && "y" !== o || !a._isStacked() ? i : l[f], b[e] = i, b[o] = n - ("x" === o && i >= 0 || "y" === o && 0 >= i ? i : 0)) : (b[o] = b["c" + o] = b[o + "Field"][0], b[e] = 1, void 0 !== g[o] && null !== g[o] && g[o].length >= 2 && (b[o + "Offset"] = g[o].indexOf(b[o + "Field"][1]), b[e] = 1 / g[o].length)) : (i = c.showPercent ? b[o + "Value"] / h[d][b[d + "Field"].join("/")] : b[o + "Value"], f = b[d + "Field"].join("/") + (b[o + "Value"] >= 0), p = j[o][f] = (null === j[o][f] || void 0 === j[o][f] || "z" === o ? 0 : j[o][f]) + i, n = b[o + "Bound"] = b["c" + o] = "x" !== o && "y" !== o || !a._isStacked() ? i : p, b[e] = i, b[o] = n - ("x" === o && i >= 0 || "y" === o && 0 >= i ? i : 0)))
                    };
                    o(a.x, "y", "width"), o(a.y, "x", "height"), o(a.z, "z", "r"), null !== a.c && null !== i.min && null !== i.max && (i.min === i.max && (i.min -= .5, i.max += .5), i.min = null !== a.c.overrideMin && void 0 !== a.c.overrideMin ? a.c.overrideMin : i.min, i.max = null !== a.c.overrideMax && void 0 !== a.c.overrideMax ? a.c.overrideMax : i.max, b.cValue = b.cValue > i.max ? i.max : b.cValue < i.min ? i.min : b.cValue, e = d3.scale.linear().range([0, null === a.c.colors || 1 === a.c.colors.length ? 1 : a.c.colors.length - 1]).domain([i.min, i.max]), f = e(b.cValue), n = f - Math.floor(f), b.cValue === i.max && (n = 1), null !== a.c.colors && void 0 !== a.c.colors && 1 === a.c.colors.length ? (c = d3.rgb(a.c.colors[0]), d = d3.rgb(this.getColor(b.aggField.slice(-1)[0]).fill)) : null !== a.c.colors && void 0 !== a.c.colors && a.c.colors.length > 1 ? (c = d3.rgb(a.c.colors[Math.floor(f)]), d = d3.rgb(a.c.colors[Math.ceil(f)])) : (c = d3.rgb("white"), d = d3.rgb(this.getColor(b.aggField.slice(-1)[0]).fill)), c.r = Math.floor(c.r + (d.r - c.r) * n), c.g = Math.floor(c.g + (d.g - c.g) * n), c.b = Math.floor(c.b + (d.b - c.b) * n), b.fill = c.toString(), b.stroke = c.darker(.5).toString())
                }, this), a._positionData = d
            }, this)
        }, this._handleTransition = function(a, b, c, d) {
            var e = null;
            return e = 0 === b ? a : a.transition().duration(b).delay(c._getDelay(b, c, d)).ease(c.ease)
        }, this._heightPixels = function() {
            return dimple._parseYPosition(this.height, this.svg.node())
        }, this._registerEventHandlers = function(a) {
            null !== a._eventHandlers && a._eventHandlers.length > 0 && a._eventHandlers.forEach(function(b) {
                var c = null;
                null !== b.handler && "function" == typeof b.handler && (c = null !== a._markers && void 0 !== a._markers ? a._markers : a.shapes, c.on(b.event, function(c) {
                    var d = new dimple.eventArgs;
                    null !== a.chart.storyboard && (d.frameValue = a.chart.storyboard.getFrameValue()), d.seriesValue = c.aggField, d.xValue = c.x, d.yValue = c.y, d.zValue = c.z, d.colorValue = c.cValue, d.seriesShapes = a.shapes, d.selectedShape = d3.select(this), b.handler(d)
                }))
            }, this)
        }, this._widthPixels = function() {
            return dimple._parseXPosition(this.width, this.svg.node())
        }, this._xPixels = function() {
            return dimple._parseXPosition(this.x, this.svg.node())
        }, this._yPixels = function() {
            return dimple._parseYPosition(this.y, this.svg.node())
        }, this.addAxis = function(a, b, c, d) {
            var e = null,
                f = null;
            if (null !== b && void 0 !== b && (b = [].concat(b)), "string" == typeof a || a instanceof String) e = new dimple.axis(this, a, b, c, d), this.axes.push(e);
            else {
                if (f = a, e = new dimple.axis(this, f.position, b, c, d), e._hasMeasure() !== f._hasMeasure()) throw "You have specified a composite axis where some but not all axes have a measure - this is not supported, all axes must be of the same type.";
                if (e._hasTimeField() !== f._hasTimeField()) throw "You have specified a composite axis where some but not all axes have a time field - this is not supported, all axes must be of the same type.";
                if ((null === e.categoryFields || void 0 === e.categoryFields ? 0 : e.categoryFields.length) !== (null === f.categoryFields || void 0 === f.categoryFields ? 0 : f.categoryFields.length)) throw "You have specified a composite axis where axes have differing numbers of category fields - this is not supported, all axes must be of the same type.";
                f._slaves.push(e)
            }
            return e
        }, this.addCategoryAxis = function(a, b) {
            return this.addAxis(a, b, null)
        }, this.addColorAxis = function(a, b) {
            var c = this.addAxis("c", null, a);
            return c.colors = null === b || void 0 === b ? null : [].concat(b), c
        }, this.addLegend = function(a, b, c, d, e, f) {
            f = null === f || void 0 === f ? this.series : [].concat(f), e = null === e || void 0 === e ? "left" : e;
            var g = new dimple.legend(this, a, b, c, d, e, f);
            return this.legends.push(g), g
        }, this.addLogAxis = function(a, b, c) {
            var d = this.addAxis(a, null, b, null);
            return null !== c && void 0 !== c && (d.logBase = c), d.useLog = !0, d
        }, this.addMeasureAxis = function(a, b) {
            return this.addAxis(a, null, b)
        }, this.addPctAxis = function(a, b, c) {
            var d = null;
            return d = null !== c && void 0 !== c ? this.addAxis(a, c, b) : this.addMeasureAxis(a, b), d.showPercent = !0, d
        }, this.addSeries = function(a, b, c) {
            (null === c || void 0 === c) && (c = this.axes), (null === b || void 0 === b) && (b = dimple.plot.bubble);
            var d, e = null,
                f = null,
                g = null,
                h = null;
            return c.forEach(function(a) {
                null !== a && b.supportedAxes.indexOf(a.position) > -1 && (null === e && "x" === a.position[0] ? e = a : null === f && "y" === a.position[0] ? f = a : null === g && "z" === a.position[0] ? g = a : null === h && "c" === a.position[0] && (h = a))
            }, this), null !== a && void 0 !== a && (a = [].concat(a)), d = new dimple.series(this, a, e, f, g, h, b, dimple.aggregateMethod.sum, b.stacked), this.series.push(d), d
        }, this.addTimeAxis = function(a, b, c, d) {
            var e = this.addAxis(a, null, null, b);
            return e.tickFormat = d, e.dateParseFormat = c, e
        }, this.assignColor = function(a, b, c, d) {
            return this._assignedColors[a] = new dimple.color(b, c, d), this._assignedColors[a]
        }, this.defaultColors = [new dimple.color("#80B1D3"), new dimple.color("#FB8072"), new dimple.color("#FDB462"), new dimple.color("#B3DE69"), new dimple.color("#FFED6F"), new dimple.color("#BC80BD"), new dimple.color("#8DD3C7"), new dimple.color("#CCEBC5"), new dimple.color("#FFFFB3"), new dimple.color("#BEBADA"), new dimple.color("#FCCDE5"), new dimple.color("#D9D9D9")], this.draw = function(a, b) {
            a = null === a || void 0 === a ? 0 : a;
            var c, d, e = null,
                f = null,
                g = !1,
                h = !1,
                i = this._xPixels(),
                j = this._yPixels(),
                k = this._widthPixels(),
                l = this._heightPixels();
            return (void 0 === b || null === b || b === !1) && this._getSeriesData(), this.axes.forEach(function(a) {
                a._scale = null
            }, this), this.axes.forEach(function(a) {
                if (a._min = 0, a._max = 0, d = [], a._hasMeasure()) {
                    var b = !1;
                    this.series.forEach(function(c) {
                        if (c._deepMatch(a)) {
                            var d = c._axisBounds(a.position);
                            a._min > d.min && (a._min = d.min), a._max < d.max && (a._max = d.max), b = !0
                        }
                    }, this), b || this._getAllData().forEach(function(b) {
                        a._min > b[a.measure] && (a._min = b[a.measure]), a._max < b[a.measure] && (a._max = b[a.measure])
                    }, this)
                } else a._hasTimeField() ? (a._min = null, a._max = null, this.series.forEach(function(b) {
                    b._deepMatch(a) && null !== b[a.position].timeField && void 0 !== b[a.position].timeField && -1 === d.indexOf(b[a.position].timeField) && d.push(b[a.position].timeField)
                }, this), a._getAxisData().forEach(function(b) {
                    d.forEach(function(c) {
                        var d = a._parseDate(b[c]);
                        (null === a._min || d < a._min) && (a._min = d), (null === a._max || d > a._max) && (a._max = d)
                    }, this)
                }, this)) : a._hasCategories() && (a._min = 0, c = [], this.series.forEach(function(b) {
                    b._deepMatch(a) && null !== b[a.position].categoryFields[0] && void 0 !== b[a.position].categoryFields[0] && -1 === d.indexOf(b[a.position].categoryFields[0]) && d.push(b[a.position].categoryFields[0])
                }, this), a._getAxisData().forEach(function(a) {
                    d.forEach(function(b) {
                        -1 === c.indexOf(a[b]) && c.push(a[b])
                    }, this)
                }, this), a._max = c.length);
                null !== a._slaves && void 0 !== a._slaves && a._slaves.length > 0 && a._slaves.forEach(function(b) {
                    b._min = a._min, b._max = a._max
                }, this), a._update(), null === e && "x" === a.position ? e = a : null === f && "y" === a.position && (f = a)
            }, this), this.axes.forEach(function(b) {
                var c = !1,
                    d = null,
                    m = 0,
                    n = null,
                    o = !1,
                    p = 0,
                    q = {
                        l: null,
                        t: null,
                        r: null,
                        b: null
                    },
                    r = 0,
                    s = 0,
                    t = "",
                    u = this,
                    v = function(b) {
                        var e;
                        return e = null === d || 0 === a || c ? b : u._handleTransition(b, a, u)
                    },
                    w = function() {
                        b.measure || ("x" === b.position ? d3.select(this).selectAll("text").attr("x", k / b._max / 2) : "y" === b.position && d3.select(this).selectAll("text").attr("y", -1 * (l / b._max) / 2)), b.categoryFields && b.categoryFields.length > 0 && (b !== e || null !== f.categoryFields && 0 !== f.categoryFields.length || d3.select(this).selectAll("text").attr("y", j + l - f._scale(0) + 9), b !== f || null !== e.categoryFields && 0 !== e.categoryFields.length || d3.select(this).selectAll("text").attr("x", -1 * (e._scale(0) - i) - 9))
                    };
                null === b.gridlineShapes ? (b.showGridlines || null === b.showGridlines && !b._hasCategories() && (!g && "x" === b.position || !h && "y" === b.position)) && (b.gridlineShapes = this._group.append("g").attr("class", "dimple-gridline"), "x" === b.position ? g = !0 : h = !0) : "x" === b.position ? g = !0 : h = !0, null === b.shapes && (b.shapes = this._group.append("g").attr("class", "dimple-axis").each(function() {
                    u.noFormats || d3.select(this).style("font-family", b.fontFamily).style("font-size", b._getFontSize())
                }), c = !0), b === e && null !== f ? (d = "translate(0, " + (null === f.categoryFields || 0 === f.categoryFields.length ? f._scale(0) : j + l) + ")", n = "translate(0, " + (b === e ? j + l : j) + ")", m = -l) : b === f && null !== e ? (d = "translate(" + (null === e.categoryFields || 0 === e.categoryFields.length ? e._scale(0) : i) + ", 0)", n = "translate(" + (b === f ? i : i + k) + ", 0)", m = -k) : "x" === b.position ? (n = d = "translate(0, " + (b === e ? j + l : j) + ")", m = -l) : "y" === b.position && (n = d = "translate(" + (b === f ? i : i + k) + ", 0)", m = -k), null !== d && null !== b._draw && (b._hasTimeField() ? v(b.shapes).call(b._draw.ticks(b._getTimePeriod(), b.timeInterval).tickFormat(b._getFormat())).attr("transform", d).each(w) : b.useLog ? v(b.shapes).call(b._draw.ticks(4, b._getFormat())).attr("transform", d).each(w) : v(b.shapes).call(b._draw.tickFormat(b._getFormat())).attr("transform", d).each(w), null !== b.gridlineShapes && v(b.gridlineShapes).call(b._draw.tickSize(m, 0, 0).tickFormat("")).attr("transform", n)), this.noFormats || (v(b.shapes.selectAll("text")).style("font-family", b.fontFamily).style("font-size", b._getFontSize()), v(b.shapes.selectAll("path, line")).style("fill", "none").style("stroke", "black").style("shape-rendering", "crispEdges"), null !== b.gridlineShapes && v(b.gridlineShapes.selectAll("line")).style("fill", "none").style("stroke", "lightgray").style("opacity", .8)), (null === b.measure || void 0 === b.measure) && (b === e ? (p = 0, b.shapes.selectAll("text").each(function() {
                    var a = this.getComputedTextLength();
                    p = a > p ? a : p
                }), p > k / b.shapes.selectAll("text")[0].length ? (o = !0, b.shapes.selectAll("text").style("text-anchor", "start").each(function() {
                    var a = this.getBBox();
                    d3.select(this).attr("transform", "rotate(90," + a.x + "," + (a.y + a.height / 2) + ") translate(-5, 0)")
                })) : (o = !1, b.shapes.selectAll("text").style("text-anchor", "middle").attr("transform", ""))) : "x" === b.position && (p = 0, b.shapes.selectAll("text").each(function() {
                    var a = this.getComputedTextLength();
                    p = a > p ? a : p
                }), p > k / b.shapes.selectAll("text")[0].length ? (o = !0, b.shapes.selectAll("text").style("text-anchor", "end").each(function() {
                    var a = this.getBBox();
                    d3.select(this).attr("transform", "rotate(90," + (a.x + a.width) + "," + (a.y + a.height / 2) + ") translate(5, 0)")
                })) : (o = !1, b.shapes.selectAll("text").style("text-anchor", "middle").attr("transform", "")))), null !== b.titleShape && void 0 !== b.titleShape && b.titleShape.remove(), b.shapes.selectAll("text").each(function() {
                    var a = this.getBBox();
                    (null === q.l || -9 - a.width < q.l) && (q.l = -9 - a.width), (null === q.r || a.x + a.width > q.r) && (q.r = a.x + a.width), o ? ((null === q.t || a.y + a.height - a.width < q.t) && (q.t = a.y + a.height - a.width), (null === q.b || a.height + a.width > q.b) && (q.b = a.height + a.width)) : ((null === q.t || a.y < q.t) && (q.t = a.y), (null === q.b || 9 + a.height > q.b) && (q.b = 9 + a.height))
                }), "x" === b.position ? (s = b === e ? j + l + q.b + 5 : j + q.t - 10, r = i + k / 2) : "y" === b.position && (r = b === f ? i + q.l - 10 : i + k + q.r + 20, s = j + l / 2, t = "rotate(270, " + r + ", " + s + ")"), b.hidden || "x" !== b.position && "y" !== b.position || null === b.title || (b.titleShape = this._group.append("text").attr("class", "dimple-axis dimple-title"), b.titleShape.attr("x", r).attr("y", s).attr("text-anchor", "middle").attr("transform", t).text(void 0 !== b.title ? b.title : null === b.categoryFields || void 0 === b.categoryFields || 0 === b.categoryFields.length ? b.measure : b.categoryFields.join("/")).each(function() {
                    u.noFormats || d3.select(this).style("font-family", b.fontFamily).style("font-size", b._getFontSize())
                }), b === e ? b.titleShape.each(function() {
                    d3.select(this).attr("y", s + this.getBBox().height / 1.65)
                }) : b === f && b.titleShape.each(function() {
                    d3.select(this).attr("x", r + this.getBBox().height / 1.65)
                }))
            }, this), this.series.forEach(function(b) {
                b.plot.draw(this, b, a), this._registerEventHandlers(b)
            }, this), this.legends.forEach(function(b) {
                b._draw(a)
            }, this), null !== this.storyboard && void 0 !== this.storyboard && (this.storyboard._drawText(), this.storyboard.autoplay && this.storyboard.startAnimation()), this
        }, this.getColor = function(a) {
            return (null === this._assignedColors[a] || void 0 === this._assignedColors[a]) && (this._assignedColors[a] = this.defaultColors[this._nextColor], this._nextColor = (this._nextColor + 1) % this.defaultColors.length), this._assignedColors[a]
        }, this.setBounds = function(a, b, c, d) {
            return this.x = a, this.y = b, this.width = c, this.height = d, this._xPixels = function() {
                return dimple._parseXPosition(this.x, this.svg.node())
            }, this._yPixels = function() {
                return dimple._parseYPosition(this.y, this.svg.node())
            }, this._widthPixels = function() {
                return dimple._parseXPosition(this.width, this.svg.node())
            }, this._heightPixels = function() {
                return dimple._parseYPosition(this.height, this.svg.node())
            }, this.draw(0, !0), this
        }, this.setMargins = function(a, b, c, d) {
            return this.x = a, this.y = b, this.width = 0, this.height = 0, this._xPixels = function() {
                return dimple._parseXPosition(this.x, this.svg.node())
            }, this._yPixels = function() {
                return dimple._parseYPosition(this.y, this.svg.node())
            }, this._widthPixels = function() {
                return dimple._parentWidth(this.svg.node()) - this._xPixels() - dimple._parseXPosition(c, this.svg.node())
            }, this._heightPixels = function() {
                return dimple._parentHeight(this.svg.node()) - this._yPixels() - dimple._parseYPosition(d, this.svg.node())
            }, this.draw(0, !0), this
        }, this.setStoryboard = function(a, b) {
            return this.storyboard = new dimple.storyboard(this, a), null !== b && void 0 !== b && (this.storyboard.onTick = b), this.storyboard
        }
    }, dimple.color = function(a, b, c) {
        this.fill = a, this.stroke = null === b || void 0 === b ? d3.rgb(a).darker(.5).toString() : b, this.opacity = null === c || void 0 === c ? .8 : c
    }, dimple.eventArgs = function() {
        this.seriesValue = null, this.xValue = null, this.yValue = null, this.zValue = null, this.colorValue = null, this.frameValue = null, this.seriesShapes = null, this.selectedShape = null
    }, dimple.legend = function(a, b, c, d, e, f, g) {
        this.chart = a, this.series = g, this.x = b, this.y = c, this.width = d, this.height = e, this.horizontalAlign = f, this.shapes = null, this.fontSize = "10px", this.fontFamily = "sans-serif", this._draw = function(a) {
            var b, c = this._getEntries(),
                d = 0,
                e = 0,
                f = 0,
                g = 0,
                h = 15,
                i = 9,
                j = this;
            null !== this.shapes && void 0 !== this.shapes && this.shapes.transition().duration(.2 * a).attr("opacity", 0).remove(), b = this.chart._group.selectAll(".dimple-dont-select-any").data(c).enter().append("g").attr("class", function(a) {
                return "dimple-legend " + dimple._createClass(a.aggField)
            }).attr("opacity", 0), b.append("text").attr("class", function(a) {
                return "dimple-legend dimple-legend-text " + dimple._createClass(a.aggField)
            }).text(function(a) {
                return a.key
            }).call(function() {
                j.chart.noFormats || this.style("font-family", j.fontFamily).style("font-size", j._getFontSize()).style("shape-rendering", "crispEdges")
            }).each(function() {
                var a = this.getBBox();
                a.width > d && (d = a.width), a.height > e && (e = a.height)
            }), b.append("rect").attr("class", function(a) {
                return "dimple-legend dimple-legend-key " + dimple._createClass(a.aggField)
            }).attr("height", i).attr("width", h), e = (i > e ? i : e) + 2, d += h + 20, b.each(function(a) {
                f + d > j._widthPixels() && (f = 0, g += e), g > j._heightPixels() ? d3.select(this).remove() : (d3.select(this).select("text").attr("x", "left" === j.horizontalAlign ? j._xPixels() + h + 5 + f : j._xPixels() + (j._widthPixels() - f - d) + h + 5).attr("y", function() {
                    return j._yPixels() + g + this.getBBox().height / 1.65
                }).attr("width", j._widthPixels()).attr("height", j._heightPixels()), d3.select(this).select("rect").attr("class", function(a) {
                    return "dimple-legend dimple-legend-key " + dimple._createClass(a.aggField)
                }).attr("x", "left" === j.horizontalAlign ? j._xPixels() + f : j._xPixels() + (j._widthPixels() - f - d)).attr("y", j._yPixels() + g).attr("height", i).attr("width", h).style("fill", a.fill).style("stroke", a.stroke).style("opacity", a.opacity).style("shape-rendering", "crispEdges"), f += d)
            }), b.transition().delay(.2 * a).duration(.8 * a).attr("opacity", 1), this.shapes = b
        }, this._getEntries = function() {
            var a = [];
            return this.series && this.series.forEach(function(b) {
                var c = b._positionData;
                c.forEach(function(c) {
                    var d, e = -1,
                        f = b.plot.grouped && !b.x._hasCategories() && !b.y._hasCategories() && c.aggField.length < 2 ? "All" : c.aggField.slice(-1)[0];
                    for (d = 0; d < a.length; d += 1)
                        if (a[d].key === f) {
                            e = d;
                            break
                        } - 1 === e && b.chart._assignedColors[f] && (a.push({
                        key: f,
                        fill: b.chart._assignedColors[f].fill,
                        stroke: b.chart._assignedColors[f].stroke,
                        opacity: b.chart._assignedColors[f].opacity,
                        series: b,
                        aggField: c.aggField
                    }), e = a.length - 1)
                })
            }, this), a
        }, this._getFontSize = function() {
            var a;
            return a = this.fontSize && "auto" !== this.fontSize.toString().toLowerCase() ? isNaN(this.fontSize) ? this.fontSize : this.fontSize + "px" : (this.chart._heightPixels() / 35 > 10 ? this.chart._heightPixels() / 35 : 10) + "px"
        }, this._heightPixels = function() {
            return dimple._parseYPosition(this.height, this.chart.svg.node())
        }, this._widthPixels = function() {
            return dimple._parseXPosition(this.width, this.chart.svg.node())
        }, this._xPixels = function() {
            return dimple._parseXPosition(this.x, this.chart.svg.node())
        }, this._yPixels = function() {
            return dimple._parseYPosition(this.y, this.chart.svg.node())
        }
    }, dimple.series = function(a, b, c, d, e, f, g, h, i) {
        this.chart = a, this.x = c, this.y = d, this.z = e, this.c = f, this.plot = g, this.categoryFields = b, this.aggregate = h, this.stacked = i, this.barGap = .2, this.clusterBarGap = .1, this.lineWeight = 2, this.lineMarkers = !1, this.afterDraw = null, this.interpolation = "linear", this.tooltipFontSize = "10px", this.tooltipFontFamily = "sans-serif", this._eventHandlers = [], this._positionData = [], this._orderRules = [], this._axisBounds = function(a) {
            var b, c, d, e = {
                    min: 0,
                    max: 0
                },
                f = null,
                g = null,
                h = [],
                i = 0,
                j = this._positionData;
            return "x" === a ? (f = this.x, g = this.y) : "y" === a ? (f = this.y, g = this.x) : "z" === a ? f = this.z : "c" === a && (f = this.c), f.showPercent ? j.forEach(function(a) {
                a[f.position + "Bound"] < e.min && (e.min = a[f.position + "Bound"]), a[f.position + "Bound"] > e.max && (e.max = a[f.position + "Bound"])
            }, this) : null === g || null === g.categoryFields || 0 === g.categoryFields.length ? j.forEach(function(a) {
                !this._isStacked() || "x" !== f.position && "y" !== f.position ? (a[f.position + "Value"] < e.min && (e.min = a[f.position + "Value"]), a[f.position + "Value"] > e.max && (e.max = a[f.position + "Value"])) : a[f.position + "Value"] < 0 ? e.min = e.min + a[f.position + "Value"] : e.max = e.max + a[f.position + "Value"]
            }, this) : (b = f.position + "Value", c = g.position + "Field", d = [], j.forEach(function(a) {
                var e = a[c].join("/"),
                    f = d.indexOf(e); - 1 === f && (d.push(e), f = d.length - 1), void 0 === h[f] && (h[f] = {
                    min: 0,
                    max: 0
                }, f >= i && (i = f + 1)), this.stacked ? a[b] < 0 ? h[f].min = h[f].min + a[b] : h[f].max = h[f].max + a[b] : (a[b] < h[f].min && (h[f].min = a[b]), a[b] > h[f].max && (h[f].max = a[b]))
            }, this), h.forEach(function(a) {
                void 0 !== a && (a.min < e.min && (e.min = a.min), a.max > e.max && (e.max = a.max))
            }, this)), e
        }, this._deepMatch = function(a) {
            var b = !1;
            return this[a.position] === a ? b = !0 : void 0 !== a._slaves && null !== a._slaves && a._slaves.length > 0 && a._slaves.forEach(function(a) {
                b = b || this._deepMatch(a)
            }, this), b
        }, this._dropLineOrigin = function() {
            var a = 0,
                b = 0,
                c = {
                    x: null,
                    y: null
                },
                d = {
                    x: null,
                    y: null
                };
            return this.chart.axes.forEach(function(a) {
                "x" === a.position && null === d.x ? d.x = a._hasTimeField() ? this.chart._xPixels() : a._origin : "y" === a.position && null === d.y && (d.y = a._hasTimeField() ? this.chart._yPixels() + this.chart._heightPixels() : a._origin)
            }, this), this.chart.axes.forEach(function(e) {
                "x" !== e.position || this.x.hidden ? "y" !== e.position || this.y.hidden || (this._deepMatch(e) && (0 === b ? c.x = d.x : 1 === b && (c.x = this.chart._xPixels() + this.chart._widthPixels())), b += 1) : (this._deepMatch(e) && (0 === a ? c.y = d.y : 1 === a && (c.y = this.chart._yPixels())), a += 1)
            }, this), c
        }, this._getTooltipFontSize = function() {
            var a;
            return a = this.tooltipFontSize && "auto" !== this.tooltipFontSize.toString().toLowerCase() ? isNaN(this.tooltipFontSize) ? this.tooltipFontSize : this.tooltipFontSize + "px" : (this.chart._heightPixels() / 35 > 10 ? this.chart._heightPixels() / 35 : 10) + "px"
        }, this._isStacked = function() {
            return this.stacked && (this.x._hasCategories() || this.y._hasCategories())
        }, this.addEventHandler = function(a, b) {
            this._eventHandlers.push({
                event: a,
                handler: b
            })
        }, this.addOrderRule = function(a, b) {
            this._orderRules.push({
                ordering: a,
                desc: b
            })
        }, this.getTooltipText = function(a) {
            var b = [];
            return null !== this.categoryFields && void 0 !== this.categoryFields && this.categoryFields.length > 0 && this.categoryFields.forEach(function(c, d) {
                null !== c && void 0 !== c && null !== a.aggField[d] && void 0 !== a.aggField[d] && b.push(c + (a.aggField[d] !== c ? ": " + a.aggField[d] : ""))
            }, this), this.x && this.x._getTooltipText(b, a), this.y && this.y._getTooltipText(b, a), this.z && this.z._getTooltipText(b, a), this.c && this.c._getTooltipText(b, a), b.filter(function(a, c) {
                return b.indexOf(a) === c
            })
        }
    }, dimple.storyboard = function(a, b) {
        null !== b && void 0 !== b && (b = [].concat(b)), this.chart = a, this.categoryFields = b, this.autoplay = !0, this.frameDuration = 3e3, this.storyLabel = null, this.onTick = null, this.fontSize = "10px", this.fontFamily = "sans-serif", this._frame = 0, this._animationTimer = null, this._categories = [], this._cachedCategoryFields = [], this._orderRules = [], this._drawText = function(a) {
            if (null === this.storyLabel || void 0 === this.storyLabel) {
                var b = this.chart,
                    c = this,
                    d = 0;
                this.chart.axes.forEach(function(a) {
                    "x" === a.position && (d += 1)
                }, this), this.storyLabel = this.chart._group.append("text").attr("x", this.chart._xPixels() + .01 * this.chart._widthPixels()).attr("y", this.chart._yPixels() + (this.chart._heightPixels() / 35 > 10 ? this.chart._heightPixels() / 35 : 10) * (d > 1 ? 1.25 : -1)).call(function() {
                    b.noFormats || this.style("font-family", c.fontFamily).style("font-size", c._getFontSize())
                })
            }
            this.storyLabel.transition().duration(.2 * a).ease(this.chart.ease).attr("opacity", 0), this.storyLabel.transition().delay(.2 * a).ease(this.chart.ease).attr("class", "dimple-storyboard-label").text(this.categoryFields.join("\\") + ": " + this.getFrameValue()).transition().duration(.8 * a).attr("opacity", 1)
        }, this._getCategories = function() {
            return this._categoryFields !== this._cachedCategoryFields && (this._categories = [], this.chart._getAllData().forEach(function(a) {
                var b = -1,
                    c = "";
                null !== this.categoryFields && (this.categoryFields.forEach(function(b, d) {
                    d > 0 && (c += "/"), c += a[b]
                }, this), b = this._categories.indexOf(c), -1 === b && (this._categories.push(c), b = this._categories.length - 1))
            }, this), this._cachedCategoryFields = this._categoryFields), this._categories
        }, this._getFontSize = function() {
            var a;
            return a = this.fontSize && "auto" !== this.fontSize.toString().toLowerCase() ? isNaN(this.fontSize) ? this.fontSize : this.fontSize + "px" : (this.chart._heightPixels() / 35 > 10 ? this.chart._heightPixels() / 35 : 10) + "px"
        }, this._goToFrameIndex = function(a) {
            this._frame = a % this._getCategories().length, this.chart.draw(this.frameDuration / 2)
        }, this.addOrderRule = function(a, b) {
            this._orderRules.push({
                ordering: a,
                desc: b
            })
        }, this.getFrameValue = function() {
            var a = null;
            return this._frame >= 0 && this._getCategories().length > this._frame && (a = this._getCategories()[this._frame]), a
        }, this.goToFrame = function(a) {
            if (this._getCategories().length > 0) {
                var b = this._getCategories().indexOf(a);
                this._goToFrameIndex(b)
            }
        }, this.pauseAnimation = function() {
            null !== this._animationTimer && (window.clearInterval(this._animationTimer), this._animationTimer = null)
        }, this.startAnimation = function() {
            null === this._animationTimer && (null !== this.onTick && this.onTick(this.getFrameValue()), this._animationTimer = window.setInterval(function(a) {
                return function() {
                    a._goToFrameIndex(a._frame + 1), null !== a.onTick && a.onTick(a.getFrameValue()), a._drawText(a.frameDuration / 2)
                }
            }(this), this.frameDuration))
        }, this.stopAnimation = function() {
            null !== this._animationTimer && (window.clearInterval(this._animationTimer), this._animationTimer = null, this._frame = 0)
        }
    }, dimple.aggregateMethod.avg = function(a, b) {
        return a.value = null === a.value || void 0 === a.value ? 0 : parseFloat(a.value), a.count = null === a.count || void 0 === a.count ? 1 : parseFloat(a.count), b.value = null === b.value || void 0 === b.value ? 0 : parseFloat(b.value), b.count = null === b.count || void 0 === b.count ? 1 : parseFloat(b.count), (a.value * a.count + b.value * b.count) / (a.count + b.count)
    }, dimple.aggregateMethod.count = function(a, b) {
        return a.count = null === a.count || void 0 === a.count ? 0 : parseFloat(a.count), b.count = null === b.count || void 0 === b.count ? 0 : parseFloat(b.count), a.count + b.count
    }, dimple.aggregateMethod.max = function(a, b) {
        return a.value = null === a.value || void 0 === a.value ? 0 : parseFloat(a.value), b.value = null === b.value || void 0 === b.value ? 0 : parseFloat(b.value), a.value > b.value ? a.value : b.value
    }, dimple.aggregateMethod.min = function(a, b) {
        return null === a.value ? parseFloat(b.value) : parseFloat(a.value) < parseFloat(b.value) ? parseFloat(a.value) : parseFloat(b.value)
    }, dimple.aggregateMethod.sum = function(a, b) {
        return a.value = null === a.value || void 0 === a.value ? 0 : parseFloat(a.value), b.value = null === b.value || void 0 === b.value ? 0 : parseFloat(b.value), a.value + b.value
    }, dimple.plot.area = {
        stacked: !0,
        grouped: !0,
        supportedAxes: ["x", "y", "c"],
        draw: function(a, b, c) {
            var d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z = b._positionData,
                A = [],
                B = null,
                C = "dimple-series-" + a.series.indexOf(b),
                D = b.x._hasCategories() || b.y._hasCategories() ? 0 : 1,
                E = !1,
                F = {},
                G = [],
                H = [],
                I = function() {
                    return function(a, b, c, d) {
                        d3.select(b).style("opacity", 1), dimple._showPointTooltip(a, b, c, d)
                    }
                },
                J = function(a) {
                    return function(b, c, d, e) {
                        d3.select(c).style("opacity", e.lineMarkers || a.data.length < 2 ? dimple._helpers.opacity(b, d, e) : 0), dimple._removeTooltip(b, c, d, e)
                    }
                },
                K = function(d) {
                    dimple._drawMarkers(d, a, b, c, C, E, I(d), J(d))
                },
                L = function(c, d) {
                    var e;
                    return "step" === b.interpolation && b[c]._hasCategories() ? (e = dimple._helpers[c](d, a, b) + ("y" === c ? dimple._helpers.height(d, a, b) : 0), b[c].categoryFields.length < 2 && (e += ("y" === c ? 1 : -1) * dimple._helpers[c + "Gap"](a, b))) : e = dimple._helpers["c" + c](d, a, b), parseFloat(e.toFixed(1))
                },
                M = function(a, c) {
                    return d3.svg.line().x(function(a) {
                        return b.x._hasCategories() || !c ? a.x : b.x[c]
                    }).y(function(a) {
                        return b.y._hasCategories() || !c ? a.y : b.y[c]
                    }).interpolate(a)
                },
                N = function(a, b) {
                    return parseFloat(a) - parseFloat(b)
                },
                O = function(a, b) {
                    return parseFloat(a.x) - parseFloat(b.x)
                },
                P = function(a, b, c) {
                    var d, e, f = b[b.length - 1],
                        g = 9999,
                        h = f;
                    for (d = 0; d < a.length; d += 1)(a[d].x !== f.x || a[d].y !== f.y) && (e = 180 - Math.atan2(a[d].x - f.x, a[d].y - f.y) * (180 / Math.PI), e > c && g > e && (h = a[d], g = e));
                    return b.push(h), g
                };
            for (d = "step" === b.interpolation ? "step-after" : b.interpolation, m = dimple._getSeriesOrder(b.data || a.data, b), b.c && (b.x._hasCategories() && b.y._hasMeasure() || b.y._hasCategories() && b.x._hasMeasure()) && (E = !0), b.x._hasCategories() ? (x = "x", y = "y") : b.y._hasCategories() && (x = "y", y = "x"), e = 0; e < z.length; e += 1) {
                for (h = [], j = -1, g = D; g < z[e].aggField.length; g += 1) h.push(z[e].aggField[g]);
                for (i = dimple._createClass(h), g = 0; g < A.length; g += 1)
                    if (A[g].keyString === i) {
                        j = g;
                        break
                    } - 1 === j && (j = A.length, A.push({
                    key: h,
                    keyString: i,
                    color: "white",
                    data: [],
                    points: [],
                    area: {},
                    entry: {},
                    exit: {},
                    group: x && z[e][x + "Field"] && z[e][x + "Field"].length >= 2 ? z[e][x + "Field"][0] : "All"
                })), A[j].data.push(z[e])
            }
            for (m && A.sort(function(a, b) {
                    return dimple._arrayIndexCompare(m, a.key, b.key)
                }), e = 0; e < A.length; e += 1) {
                for (A[e].data.sort(dimple._getSeriesSortPredicate(a, b, m)), f = 0; f < A[e].data.length; f += 1) A[e].points.push({
                    x: L("x", A[e].data[f]),
                    y: L("y", A[e].data[f])
                }), x && (F[A[e].group] || (F[A[e].group] = {}), F[A[e].group][A[e].points[A[e].points.length - 1][x]] = b[y]._origin);
                n = A[e].points, "step" === b.interpolation && n.length > 1 && x && (b.x._hasCategories() ? (n.push({
                    x: 2 * n[n.length - 1].x - n[n.length - 2].x,
                    y: n[n.length - 1].y
                }), F[A[e].group][n[n.length - 1][x]] = b[y]._origin) : b.y._hasCategories() && (n = [{
                    x: n[0].x,
                    y: 2 * n[0].y - n[1].y
                }].concat(n), F[A[e].group][n[0][x]] = b[y]._origin, A[e].points = n))
            }
            for (q in F)
                if (F.hasOwnProperty(q)) {
                    G[q] = [];
                    for (r in F[q]) F[q].hasOwnProperty(r) && G[q].push(parseFloat(r));
                    G[q].sort(N)
                }
            for (e = 0; e < A.length; e += 1) {
                if (n = A[e].points, s = A[e].group, o = [], H = [], E && dimple._addGradient(A[e].key, "fill-area-gradient-" + A[e].keyString, b.x._hasCategories() ? b.x : b.y, z, a, c, "fill"), G[s] && G[s].length > 0)
                    for (f = 0, g = 0; f < G[s].length; f += 1) G[s][f] >= n[0][x] && G[s][f] <= n[n.length - 1][x] && (p = {}, p[x] = G[s][f], p[y] = F[s][G[s][f]], o.push(p), n[g][x] > G[s][f] ? H.push(p) : (H.push(n[g]), F[A[e].group][G[s][f]] = n[g][y], g += 1));
                else if (b._orderRules && b._orderRules.length > 0) H = n.concat(n[0]);
                else {
                    n = n.sort(O), H.push(n[0]), w = 0;
                    do w = P(n, H, w); while (H.length <= n.length && (H[0].x !== H[H.length - 1].x || H[0].y !== H[H.length - 1].y))
                }
                o = o.reverse(), t = M(d, "_previousOrigin")(H), u = M("step-after" === d ? "step-before" : "step-before" === d ? "step-after" : d, "_previousOrigin")(o), v = M("linear", "_previousOrigin")(H), A[e].entry = t + (u && u.length > 0 ? "L" + u.substring(1) : "") + (v && v.length > 0 ? "L" + v.substring(1, v.indexOf("L")) : 0), t = M(d)(H), u = M("step-after" === d ? "step-before" : "step-before" === d ? "step-after" : d)(o), v = M("linear")(H), A[e].update = t + (u && u.length > 0 ? "L" + u.substring(1) : "") + (v && v.length > 0 ? "L" + v.substring(1, v.indexOf("L")) : 0), t = M(d, "_origin")(H), u = M("step-after" === d ? "step-before" : "step-before" === d ? "step-after" : d, "_origin")(o), v = M("linear", "_origin")(H), A[e].exit = t + (u && u.length > 0 ? "L" + u.substring(1) : "") + (v && v.length > 0 ? "L" + v.substring(1, v.indexOf("L")) : 0), A[e].color = a.getColor(A[e].key.length > 0 ? A[e].key[A[e].key.length - 1] : "All")
            }
            null !== a._tooltipGroup && void 0 !== a._tooltipGroup && a._tooltipGroup.remove(), B = null === b.shapes || void 0 === b.shapes ? a._group.selectAll("." + C).data(A) : b.shapes.data(A, function(a) {
                return a.key
            }), B.enter().append("path").attr("id", function(a) {
                return a.key
            }).attr("class", function(a) {
                return C + " dimple-line " + a.keyString
            }).attr("d", function(a) {
                return a.entry
            }).call(function() {
                a.noFormats || this.attr("opacity", function(a) {
                    return E ? 1 : a.color.opacity
                }).attr("fill", function(a) {
                    return E ? "url(#fill-area-gradient-" + a.keyString + ")" : a.color.fill
                }).attr("stroke", function(a) {
                    return E ? "url(#stroke-area-gradient-" + a.keyString + ")" : a.color.stroke
                }).attr("stroke-width", b.lineWeight)
            }).each(function(a) {
                a.markerData = a.data, K(a)
            }), k = a._handleTransition(B, c, a).attr("d", function(a) {
                return a.update
            }).each(function(a) {
                a.markerData = a.data, K(a)
            }), l = a._handleTransition(B.exit(), c, a).attr("d", function(a) {
                return a.exit
            }).each(function(a) {
                a.markerData = [], K(a)
            }), dimple._postDrawHandling(b, k, l, c), b.shapes = B
        }
    }, dimple.plot.bar = {
        stacked: !0,
        grouped: !1,
        supportedAxes: ["x", "y", "c"],
        draw: function(a, b, c) {
            var d, e, f = b._positionData,
                g = null,
                h = ["dimple-series-" + a.series.indexOf(b), "dimple-bar"],
                i = !b._isStacked() && b.x._hasMeasure(),
                j = !b._isStacked() && b.y._hasMeasure(),
                k = "none";
            b.x._hasCategories() && b.y._hasCategories() ? k = "both" : b.x._hasCategories() ? k = "x" : b.y._hasCategories() && (k = "y"), null !== a._tooltipGroup && void 0 !== a._tooltipGroup && a._tooltipGroup.remove(), g = null === b.shapes || void 0 === b.shapes ? a._group.selectAll("." + h.join(".")).data(f) : b.shapes.data(f, function(a) {
                return a.key
            }), g.enter().append("rect").attr("id", function(a) {
                return a.key
            }).attr("class", function(a) {
                var b = [];
                return b = b.concat(a.aggField), b = b.concat(a.xField), b = b.concat(a.yField), h.join(" ") + " " + dimple._createClass(b)
            }).attr("x", function(c) {
                var d = b.x._previousOrigin;
                return "x" === k ? d = dimple._helpers.x(c, a, b) : "both" === k && (d = dimple._helpers.cx(c, a, b)), d
            }).attr("y", function(c) {
                var d = b.y._previousOrigin;
                return "y" === k ? d = dimple._helpers.y(c, a, b) : "both" === k && (d = dimple._helpers.cy(c, a, b)), d
            }).attr("width", function(c) {
                return "x" === k ? dimple._helpers.width(c, a, b) : 0
            }).attr("height", function(c) {
                return "y" === k ? dimple._helpers.height(c, a, b) : 0
            }).attr("opacity", function(c) {
                return dimple._helpers.opacity(c, a, b)
            }).on("mouseover", function(c) {
                dimple._showBarTooltip(c, this, a, b)
            }).on("mouseleave", function(c) {
                dimple._removeTooltip(c, this, a, b)
            }).call(function() {
                a.noFormats || this.attr("fill", function(c) {
                    return dimple._helpers.fill(c, a, b)
                }).attr("stroke", function(c) {
                    return dimple._helpers.stroke(c, a, b)
                })
            }), d = a._handleTransition(g, c, a, b).attr("x", function(c) {
                return i ? dimple._helpers.cx(c, a, b) - b.x.floatingBarWidth / 2 : dimple._helpers.x(c, a, b)
            }).attr("y", function(c) {
                return j ? dimple._helpers.cy(c, a, b) - b.y.floatingBarWidth / 2 : dimple._helpers.y(c, a, b)
            }).attr("width", function(c) {
                return i ? b.x.floatingBarWidth : dimple._helpers.width(c, a, b)
            }).attr("height", function(c) {
                return j ? b.y.floatingBarWidth : dimple._helpers.height(c, a, b)
            }).call(function() {
                a.noFormats || this.attr("fill", function(c) {
                    return dimple._helpers.fill(c, a, b)
                }).attr("stroke", function(c) {
                    return dimple._helpers.stroke(c, a, b)
                })
            }), e = a._handleTransition(g.exit(), c, a, b).attr("x", function(c) {
                var d = b.x._origin;
                return "x" === k ? d = dimple._helpers.x(c, a, b) : "both" === k && (d = dimple._helpers.cx(c, a, b)), d
            }).attr("y", function(c) {
                var d = b.y._origin;
                return "y" === k ? d = dimple._helpers.y(c, a, b) : "both" === k && (d = dimple._helpers.cy(c, a, b)), d
            }).attr("width", function(c) {
                return "x" === k ? dimple._helpers.width(c, a, b) : 0
            }).attr("height", function(c) {
                return "y" === k ? dimple._helpers.height(c, a, b) : 0
            }), dimple._postDrawHandling(b, d, e, c), b.shapes = g
        }
    }, dimple.plot.bubble = {
        stacked: !1,
        grouped: !1,
        supportedAxes: ["x", "y", "z", "c"],
        draw: function(a, b, c) {
            var d, e, f = b._positionData,
                g = null,
                h = ["dimple-series-" + a.series.indexOf(b), "dimple-bubble"];
            null !== a._tooltipGroup && void 0 !== a._tooltipGroup && a._tooltipGroup.remove(), g = null === b.shapes || void 0 === b.shapes ? a._group.selectAll("." + h.join(".")).data(f) : b.shapes.data(f, function(a) {
                return a.key
            }), g.enter().append("circle").attr("id", function(a) {
                return a.key
            }).attr("class", function(a) {
                var b = [];
                return b = b.concat(a.aggField), b = b.concat(a.xField), b = b.concat(a.yField), b = b.concat(a.zField), h.join(" ") + " " + dimple._createClass(b)
            }).attr("cx", function(c) {
                return b.x._hasCategories() ? dimple._helpers.cx(c, a, b) : b.x._previousOrigin
            }).attr("cy", function(c) {
                return b.y._hasCategories() ? dimple._helpers.cy(c, a, b) : b.y._previousOrigin
            }).attr("r", 0).attr("opacity", function(c) {
                return dimple._helpers.opacity(c, a, b)
            }).on("mouseover", function(c) {
                dimple._showPointTooltip(c, this, a, b)
            }).on("mouseleave", function(c) {
                dimple._removeTooltip(c, this, a, b)
            }).call(function() {
                a.noFormats || this.attr("fill", function(c) {
                    return dimple._helpers.fill(c, a, b)
                }).attr("stroke", function(c) {
                    return dimple._helpers.stroke(c, a, b)
                })
            }), d = a._handleTransition(g, c, a, b).attr("cx", function(c) {
                return dimple._helpers.cx(c, a, b)
            }).attr("cy", function(c) {
                return dimple._helpers.cy(c, a, b)
            }).attr("r", function(c) {
                return dimple._helpers.r(c, a, b)
            }).call(function() {
                a.noFormats || this.attr("fill", function(c) {
                    return dimple._helpers.fill(c, a, b)
                }).attr("stroke", function(c) {
                    return dimple._helpers.stroke(c, a, b)
                })
            }), e = a._handleTransition(g.exit(), c, a, b).attr("r", 0).attr("cx", function(c) {
                return b.x._hasCategories() ? dimple._helpers.cx(c, a, b) : b.x._origin
            }).attr("cy", function(c) {
                return b.y._hasCategories() ? dimple._helpers.cy(c, a, b) : b.y._origin
            }), dimple._postDrawHandling(b, d, e, c), b.shapes = g
        }
    }, dimple.plot.line = {
        stacked: !1,
        grouped: !0,
        supportedAxes: ["x", "y", "c"],
        draw: function(a, b, c) {
            var d, e, f, g, h, i, j, k, l, m, n = b._positionData,
                o = [],
                p = null,
                q = "dimple-series-" + a.series.indexOf(b),
                r = b.x._hasCategories() || b.y._hasCategories() ? 0 : 1,
                s = !1,
                t = function() {
                    return function(a, b, c, d) {
                        d3.select(b).style("opacity", 1), dimple._showPointTooltip(a, b, c, d)
                    }
                },
                u = function(a) {
                    return function(b, c, d, e) {
                        d3.select(c).style("opacity", e.lineMarkers || a.data.length < 2 ? dimple._helpers.opacity(b, d, e) : 0), dimple._removeTooltip(b, c, d, e)
                    }
                },
                v = function(d) {
                    dimple._drawMarkers(d, a, b, c, q, s, t(d), u(d))
                },
                w = function(c, d) {
                    var e;
                    return "step" === b.interpolation && b[c]._hasCategories() ? (b.barGap = 0, b.clusterBarGap = 0, e = dimple._helpers[c](d, a, b) + ("y" === c ? dimple._helpers.height(d, a, b) : 0)) : e = dimple._helpers["c" + c](d, a, b), parseFloat(e.toFixed(1))
                },
                x = function(a, c) {
                    return d3.svg.line().x(function(a) {
                        return b.x._hasCategories() || !c ? a.x : b.x[c]
                    }).y(function(a) {
                        return b.y._hasCategories() || !c ? a.y : b.y[c]
                    }).interpolate(a)
                };
            for (d = "step" === b.interpolation ? "step-after" : b.interpolation, m = dimple._getSeriesOrder(b.data || a.data, b), b.c && (b.x._hasCategories() && b.y._hasMeasure() || b.y._hasCategories() && b.x._hasMeasure()) && (s = !0), e = 0; e < n.length; e += 1) {
                for (h = [], j = -1, g = r; g < n[e].aggField.length; g += 1) h.push(n[e].aggField[g]);
                for (i = dimple._createClass(h), g = 0; g < o.length; g += 1)
                    if (o[g].keyString === i) {
                        j = g;
                        break
                    } - 1 === j && (j = o.length, o.push({
                    key: h,
                    keyString: i,
                    color: "white",
                    data: [],
                    markerData: [],
                    points: [],
                    line: {},
                    entry: {},
                    exit: {}
                })), o[j].data.push(n[e])
            }
            for (m && o.sort(function(a, b) {
                    return dimple._arrayIndexCompare(m, a.key, b.key)
                }), e = 0; e < o.length; e += 1) {
                for (o[e].data.sort(dimple._getSeriesSortPredicate(a, b, m)), s && dimple._addGradient(o[e].key, "fill-line-gradient-" + o[e].keyString, b.x._hasCategories() ? b.x : b.y, n, a, c, "fill"), f = 0; f < o[e].data.length; f += 1) o[e].points.push({
                    x: w("x", o[e].data[f]),
                    y: w("y", o[e].data[f])
                });
                "step" === b.interpolation && o[e].points.length > 1 && (b.x._hasCategories() ? o[e].points.push({
                    x: 2 * o[e].points[o[e].points.length - 1].x - o[e].points[o[e].points.length - 2].x,
                    y: o[e].points[o[e].points.length - 1].y
                }) : b.y._hasCategories() && (o[e].points = [{
                    x: o[e].points[0].x,
                    y: 2 * o[e].points[0].y - o[e].points[1].y
                }].concat(o[e].points))), o[e].entry = x(d, "_previousOrigin")(o[e].points), o[e].update = x(d)(o[e].points), o[e].exit = x(d, "_origin")(o[e].points), o[e].color = a.getColor(o[e].key.length > 0 ? o[e].key[o[e].key.length - 1] : "All")
            }
            null !== a._tooltipGroup && void 0 !== a._tooltipGroup && a._tooltipGroup.remove(), p = null === b.shapes || void 0 === b.shapes ? a._group.selectAll("." + q).data(o) : b.shapes.data(o, function(a) {
                return a.key
            }), p.enter().append("path").attr("id", function(a) {
                return a.key
            }).attr("class", function(a) {
                return q + " dimple-line " + a.keyString
            }).attr("d", function(a) {
                return a.entry
            }).call(function() {
                a.noFormats || this.attr("opacity", function(a) {
                    return s ? 1 : a.color.opacity
                }).attr("fill", "none").attr("stroke", function(a) {
                    return s ? "url(#fill-line-gradient-" + a.keyString + ")" : a.color.stroke
                }).attr("stroke-width", b.lineWeight)
            }).each(function(a) {
                a.markerData = a.data, v(a)
            }), k = a._handleTransition(p, c, a).attr("d", function(a) {
                return a.update
            }).each(function(a) {
                a.markerData = a.data, v(a)
            }), l = a._handleTransition(p.exit(), c, a).attr("d", function(a) {
                return a.exit
            }).each(function(a) {
                a.markerData = [], v(a)
            }), dimple._postDrawHandling(b, k, l, c), b.shapes = p
        }
    }, dimple._addGradient = function(a, b, c, d, e, f, g) {
        var h = [].concat(a),
            i = e._group.select("#" + b),
            j = [],
            k = c.position + "Field",
            l = !0,
            m = [];
        d.forEach(function(a) {
            -1 === j.indexOf(a[k]) && a.aggField.join("_") === h.join("_") && j.push(a[k])
        }, this), j = j.sort(function(a, b) {
            return c._scale(a) - c._scale(b)
        }), null === i.node() && (l = !1, i = e._group.append("linearGradient").attr("id", b).attr("gradientUnits", "userSpaceOnUse").attr("x1", "x" === c.position ? c._scale(j[0]) + e._widthPixels() / j.length / 2 : 0).attr("y1", "y" === c.position ? c._scale(j[0]) - e._heightPixels() / j.length / 2 : 0).attr("x2", "x" === c.position ? c._scale(j[j.length - 1]) + e._widthPixels() / j.length / 2 : 0).attr("y2", "y" === c.position ? c._scale(j[j.length - 1]) - e._heightPixels() / j.length / 2 : 0)), j.forEach(function(a, b) {
            var c = {},
                e = 0;
            for (e = 0; e < d.length; e += 1)
                if (d[e].aggField.join("_") === h.join("_") && d[e][k].join("_") === a.join("_")) {
                    c = d[e];
                    break
                }
            m.push({
                offset: Math.round(100 * (b / (j.length - 1))) + "%",
                color: c[g]
            })
        }, this), l ? e._handleTransition(i.selectAll("stop").data(m), f, e).attr("offset", function(a) {
            return a.offset
        }).attr("stop-color", function(a) {
            return a.color
        }) : i.selectAll("stop").data(m).enter().append("stop").attr("offset", function(a) {
            return a.offset
        }).attr("stop-color", function(a) {
            return a.color
        })
    }, dimple._arrayIndexCompare = function(a, b, c) {
        var d, e, f, g, h, i;
        for (e = 0; e < a.length; e += 1) {
            for (g = !0, h = !0, i = [].concat(a[e]), f = 0; f < b.length; f += 1) g = g && b[f] === i[f];
            for (f = 0; f < c.length; f += 1) h = h && c[f] === i[f];
            if (g && h) {
                d = 0;
                break
            }
            if (g) {
                d = -1;
                break
            }
            if (h) {
                d = 1;
                break
            }
        }
        return d
    }, dimple._createClass = function(a) {
        var b, c = [],
            d = function(a) {
                var b = a.charCodeAt(0),
                    c = "-";
                return b >= 65 && 90 >= b && (c = a.toLowerCase()), c
            };
        if (a.length > 0)
            for (b = 0; b < a.length; b += 1) c.push("dimple-" + a[b].toString().replace(/[^a-z0-9]/g, d));
        else c = ["dimple-all"];
        return c.join(" ")
    }, dimple._drawMarkerBacks = function(a, b, c, d, e) {
        var f, g, h = ["dimple-marker-back", e, a.keyString];
        c.lineMarkers && (f = null === c._markerBacks || void 0 === c._markerBacks || void 0 === c._markerBacks[a.keyString] ? b._group.selectAll("." + h.join(".")).data(a.markerData) : c._markerBacks[a.keyString].data(a.markerData, function(a) {
            return a.key
        }), f.enter().append("circle").attr("id", function(a) {
            return a.key
        }).attr("class", function(a) {
            var b = [];
            return c.x._hasCategories() && (b = b.concat(a.xField)), c.y._hasCategories() && (b = b.concat(a.yField)), dimple._createClass(b) + " " + h.join(" ")
        }).attr("cx", function(a) {
            return c.x._hasCategories() ? dimple._helpers.cx(a, b, c) : c.x._previousOrigin
        }).attr("cy", function(a) {
            return c.y._hasCategories() ? dimple._helpers.cy(a, b, c) : c.y._previousOrigin
        }).attr("r", 0).attr("fill", "white").attr("stroke", "none"), b._handleTransition(f, d, b).attr("cx", function(a) {
            return dimple._helpers.cx(a, b, c)
        }).attr("cy", function(a) {
            return dimple._helpers.cy(a, b, c)
        }).attr("r", 2 + c.lineWeight), g = b._handleTransition(f.exit(), d, b).attr("cx", function(a) {
            return c.x._hasCategories() ? dimple._helpers.cx(a, b, c) : c.x._origin
        }).attr("cy", function(a) {
            return c.y._hasCategories() ? dimple._helpers.cy(a, b, c) : c.y._origin
        }).attr("r", 0), 0 === d ? g.remove() : g.each("end", function() {
            d3.select(this).remove()
        }), (void 0 === c._markerBacks || null === c._markerBacks) && (c._markerBacks = {}), c._markerBacks[a.keyString] = f)
    }, dimple._drawMarkers = function(a, b, c, d, e, f, g, h) {
        var i, j, k = ["dimple-marker", e, a.keyString];
        dimple._drawMarkerBacks(a, b, c, d, e), i = null === c._markers || void 0 === c._markers || void 0 === c._markers[a.keyString] ? b._group.selectAll("." + k.join(".")).data(a.markerData) : c._markers[a.keyString].data(a.markerData, function(a) {
            return a.key
        }), i.enter().append("circle").attr("id", function(a) {
            return a.key
        }).attr("class", function(a) {
            var b = [];
            return c.x._hasCategories() && (b = b.concat(a.xField)), c.y._hasCategories() && (b = b.concat(a.yField)), dimple._createClass(b) + " " + k.join(" ")
        }).on("mouseover", function(a) {
            g(a, this, b, c)
        }).on("mouseleave", function(a) {
            h(a, this, b, c)
        }).attr("cx", function(a) {
            return c.x._hasCategories() ? dimple._helpers.cx(a, b, c) : c.x._previousOrigin
        }).attr("cy", function(a) {
            return c.y._hasCategories() ? dimple._helpers.cy(a, b, c) : c.y._previousOrigin
        }).attr("r", 0).attr("opacity", c.lineMarkers || a.data.length < 2 ? a.color.opacity : 0).call(function() {
            b.noFormats || this.attr("fill", "white").style("stroke-width", c.lineWeight).attr("stroke", function(d) {
                return f ? dimple._helpers.fill(d, b, c) : a.color.stroke
            })
        }), b._handleTransition(i, d, b).attr("cx", function(a) {
            return dimple._helpers.cx(a, b, c)
        }).attr("cy", function(a) {
            return dimple._helpers.cy(a, b, c)
        }).attr("r", 2 + c.lineWeight).call(function() {
            b.noFormats || this.attr("fill", "white").style("stroke-width", c.lineWeight).attr("stroke", function(d) {
                return f ? dimple._helpers.fill(d, b, c) : a.color.stroke
            })
        }), j = b._handleTransition(i.exit(), d, b).attr("cx", function(a) {
            return c.x._hasCategories() ? dimple._helpers.cx(a, b, c) : c.x._origin
        }).attr("cy", function(a) {
            return c.y._hasCategories() ? dimple._helpers.cy(a, b, c) : c.y._origin
        }).attr("r", 0), 0 === d ? j.remove() : j.each("end", function() {
            d3.select(this).remove()
        }), (void 0 === c._markers || null === c._markers) && (c._markers = {}), c._markers[a.keyString] = i
    }, dimple._getOrderedList = function(a, b, c) {
        var d, e = [],
            f = [],
            g = [].concat(b),
            h = [].concat(b),
            i = [];
        return null !== c && void 0 !== c && (i = i.concat(c)), i = i.concat({
            ordering: g,
            desc: !1
        }), i.forEach(function(b) {
            var c;
            if ("function" == typeof b.ordering)
                for (c in a[0]) a[0].hasOwnProperty(c) && -1 === h.indexOf(c) && h.push(c);
            else b.ordering instanceof Array || h.push(b.ordering)
        }, this), d = dimple._rollUp(a, g, h), i.length >= 1 && (i.forEach(function(a) {
            var b = null === a.desc || void 0 === a.desc ? !1 : a.desc,
                c = a.ordering,
                d = [],
                f = "string" == typeof c ? c : null,
                h = function(a) {
                    var b, c = 0;
                    for (b = 0; b < a.length; b += 1) {
                        if (isNaN(a[b])) {
                            c = 0;
                            break
                        }
                        c += parseFloat(a[b])
                    }
                    return c
                },
                i = function(a, b) {
                    var c = 0,
                        d = h(a),
                        e = h(b);
                    return isNaN(d) || 0 === d || isNaN(e) || 0 === e ? isNaN(Date.parse(a[0])) || isNaN(Date.parse(b[0])) ? a[0] < b[0] ? c = -1 : a[0] > b[0] && (c = 1) : c = Date.parse(a[0]) - Date.parse(b[0]) : c = parseFloat(d) - parseFloat(e), c
                };
            "function" == typeof c ? e.push(function(a, d) {
                return (b ? -1 : 1) * c(a, d)
            }) : c instanceof Array ? (c.forEach(function(a) {
                d.push([].concat(a).join("|"))
            }, this), e.push(function(a, c) {
                var e, f, h, i = "",
                    j = "";
                for (h = 0; h < g.length; h += 1) h > 0 && (i += "|", j += "|"), i += a[g[h]], j += c[g[h]];
                return e = d.indexOf(i), f = d.indexOf(j), e = 0 > e ? b ? -1 : d.length : e, f = 0 > f ? b ? -1 : d.length : f, (b ? -1 : 1) * (e - f)
            })) : e.push(function(a, c) {
                var d = 0;
                return void 0 !== a[f] && void 0 !== c[f] && (d = i([].concat(a[f]), [].concat(c[f]))), (b ? -1 : 1) * d
            })
        }), d.sort(function(a, b) {
            for (var c = 0, d = 0; c < e.length && 0 === d;) d = e[c](a, b), c += 1;
            return d
        }), d.forEach(function(a) {
            var b, c = [];
            if (1 === g.length) f.push(a[g[0]]);
            else {
                for (b = 0; b < g.length; b += 1) c.push(a[g[b]]);
                f.push(c)
            }
        }, this)), f
    }, dimple._getSeriesOrder = function(a, b) {
        var c = [].concat(b._orderRules),
            d = b.categoryFields,
            e = [];
        return null !== d && void 0 !== d && d.length > 0 && (null !== b.c && void 0 !== b.c && b.c._hasMeasure() && c.push({
            ordering: b.c.measure,
            desc: !0
        }), b.x._hasMeasure() && c.push({
            ordering: b.x.measure,
            desc: !0
        }), b.y._hasMeasure() && c.push({
            ordering: b.y.measure,
            desc: !0
        }), e = dimple._getOrderedList(a, d, c)), e
    }, dimple._getSeriesSortPredicate = function(a, b, c) {
        return function(d, e) {
            var f = 0;
            return b.x._hasCategories() ? f = dimple._helpers.cx(d, a, b) < dimple._helpers.cx(e, a, b) ? -1 : 1 : b.y._hasCategories() ? f = dimple._helpers.cy(d, a, b) < dimple._helpers.cy(e, a, b) ? -1 : 1 : c && (f = dimple._arrayIndexCompare(c, d.aggField, e.aggField)), f
        }
    }, dimple._helpers = {
        cx: function(a, b, c) {
            var d = 0;
            return d = null !== c.x.measure && void 0 !== c.x.measure ? c.x._scale(a.cx) : c.x._hasCategories() && c.x.categoryFields.length >= 2 ? c.x._scale(a.cx) + dimple._helpers.xGap(b, c) + (a.xOffset + .5) * (b._widthPixels() / c.x._max - 2 * dimple._helpers.xGap(b, c)) * a.width : c.x._scale(a.cx) + b._widthPixels() / c.x._max / 2
        },
        cy: function(a, b, c) {
            var d = 0;
            return d = null !== c.y.measure && void 0 !== c.y.measure ? c.y._scale(a.cy) : null !== c.y.categoryFields && void 0 !== c.y.categoryFields && c.y.categoryFields.length >= 2 ? c.y._scale(a.cy) - b._heightPixels() / c.y._max + dimple._helpers.yGap(b, c) + (a.yOffset + .5) * (b._heightPixels() / c.y._max - 2 * dimple._helpers.yGap(b, c)) * a.height : c.y._scale(a.cy) - b._heightPixels() / c.y._max / 2
        },
        r: function(a, b, c) {
            var d = 0;
            return d = null === c.z || void 0 === c.z ? 5 : c.z._hasMeasure() ? c.z._scale(a.r) : c.z._scale(b._heightPixels() / 100)
        },
        xGap: function(a, b) {
            var c = 0;
            return (null === b.x.measure || void 0 === b.x.measure) && b.barGap > 0 && (c = a._widthPixels() / b.x._max * (b.barGap > .99 ? .99 : b.barGap) / 2), c
        },
        xClusterGap: function(a, b, c) {
            var d = 0;
            return null !== c.x.categoryFields && void 0 !== c.x.categoryFields && c.x.categoryFields.length >= 2 && c.clusterBarGap > 0 && !c.x._hasMeasure() && (d = a.width * (b._widthPixels() / c.x._max - 2 * dimple._helpers.xGap(b, c)) * (c.clusterBarGap > .99 ? .99 : c.clusterBarGap) / 2), d
        },
        yGap: function(a, b) {
            var c = 0;
            return (null === b.y.measure || void 0 === b.y.measure) && b.barGap > 0 && (c = a._heightPixels() / b.y._max * (b.barGap > .99 ? .99 : b.barGap) / 2), c
        },
        yClusterGap: function(a, b, c) {
            var d = 0;
            return null !== c.y.categoryFields && void 0 !== c.y.categoryFields && c.y.categoryFields.length >= 2 && c.clusterBarGap > 0 && !c.y._hasMeasure() && (d = a.height * (b._heightPixels() / c.y._max - 2 * dimple._helpers.yGap(b, c)) * (c.clusterBarGap > .99 ? .99 : c.clusterBarGap) / 2), d
        },
        x: function(a, b, c) {
            var d = 0;
            return d = c.x._hasTimeField() ? c.x._scale(a.x) - dimple._helpers.width(a, b, c) / 2 : null !== c.x.measure && void 0 !== c.x.measure ? c.x._scale(a.x) : c.x._scale(a.x) + dimple._helpers.xGap(b, c) + a.xOffset * (dimple._helpers.width(a, b, c) + 2 * dimple._helpers.xClusterGap(a, b, c)) + dimple._helpers.xClusterGap(a, b, c)
        },
        y: function(a, b, c) {
            var d = 0;
            return d = c.y._hasTimeField() ? c.y._scale(a.y) - dimple._helpers.height(a, b, c) / 2 : null !== c.y.measure && void 0 !== c.y.measure ? c.y._scale(a.y) : c.y._scale(a.y) - b._heightPixels() / c.y._max + dimple._helpers.yGap(b, c) + a.yOffset * (dimple._helpers.height(a, b, c) + 2 * dimple._helpers.yClusterGap(a, b, c)) + dimple._helpers.yClusterGap(a, b, c)
        },
        width: function(a, b, c) {
            var d = 0;
            return d = null !== c.x.measure && void 0 !== c.x.measure ? Math.abs(c.x._scale(a.x < 0 ? a.x - a.width : a.x + a.width) - c.x._scale(a.x)) : c.x._hasTimeField() ? c.x.floatingBarWidth : a.width * (b._widthPixels() / c.x._max - 2 * dimple._helpers.xGap(b, c)) - 2 * dimple._helpers.xClusterGap(a, b, c)
        },
        height: function(a, b, c) {
            var d = 0;
            return d = c.y._hasTimeField() ? c.y.floatingBarWidth : null !== c.y.measure && void 0 !== c.y.measure ? Math.abs(c.y._scale(a.y) - c.y._scale(a.y <= 0 ? a.y + a.height : a.y - a.height)) : a.height * (b._heightPixels() / c.y._max - 2 * dimple._helpers.yGap(b, c)) - 2 * dimple._helpers.yClusterGap(a, b, c)
        },
        opacity: function(a, b, c) {
            var d = 0;
            return d = null !== c.c && void 0 !== c.c ? a.opacity : b.getColor(a.aggField.slice(-1)[0]).opacity
        },
        fill: function(a, b, c) {
            var d = 0;
            return d = null !== c.c && void 0 !== c.c ? a.fill : b.getColor(a.aggField.slice(-1)[0]).fill
        },
        stroke: function(a, b, c) {
            var d = 0;
            return d = null !== c.c && void 0 !== c.c ? a.stroke : b.getColor(a.aggField.slice(-1)[0]).stroke
        }
    }, dimple._parentHeight = function(a) {
        var b = a.offsetHeight;
        return (0 >= b || null === b || void 0 === b) && (b = a.clientHeight), (0 >= b || null === b || void 0 === b) && (b = null === a.parentNode || void 0 === a.parentNode ? 0 : dimple._parentHeight(a.parentNode)), b
    }, dimple._parentWidth = function(a) {
        var b = a.offsetWidth;
        return (0 >= b || null === b || void 0 === b) && (b = a.clientWidth), (0 >= b || null === b || void 0 === b) && (b = null === a.parentNode || void 0 === a.parentNode ? 0 : dimple._parentWidth(a.parentNode)), b
    }, dimple._parseXPosition = function(a, b) {
        var c, d = 0;
        return null !== a && void 0 !== a && (c = a.toString().split(","), c.forEach(function(c) {
            void 0 !== c && null !== c && (isNaN(c) ? "%" === c.slice(-1) ? d += dimple._parentWidth(b) * (parseFloat(c.slice(0, c.length - 1)) / 100) : "px" === c.slice(-2) ? d += parseFloat(c.slice(0, c.length - 2)) : d = a : d += parseFloat(c))
        }, this)), 0 > d && (d = dimple._parentWidth(b) + d), d
    }, dimple._parseYPosition = function(a, b) {
        var c, d = 0;
        return null !== a && void 0 !== a && (c = a.toString().split(","), c.forEach(function(c) {
            void 0 !== c && null !== c && (isNaN(c) ? "%" === c.slice(-1) ? d += dimple._parentHeight(b) * (parseFloat(c.slice(0, c.length - 1)) / 100) : "px" === c.slice(-2) ? d += parseFloat(c.slice(0, c.length - 2)) : d = a : d += parseFloat(c))
        }, this)), 0 > d && (d = dimple._parentHeight(b) + d), d
    }, dimple._postDrawHandling = function(a, b, c, d) {
        0 === d ? (b.each(function(b, c) {
            null !== a.afterDraw && void 0 !== a.afterDraw && a.afterDraw(this, b, c)
        }), c.remove()) : (b.each("end", function(b, c) {
            null !== a.afterDraw && void 0 !== a.afterDraw && a.afterDraw(this, b, c)
        }), c.each("end", function() {
            d3.select(this).remove()
        }))
    }, dimple._removeTooltip = function(a, b, c) {
        c._tooltipGroup && c._tooltipGroup.remove()
    }, dimple._rollUp = function(a, b, c) {
        var d = [];
        return b = null !== b && void 0 !== b ? [].concat(b) : [], a.forEach(function(a) {
            var e = -1,
                f = {},
                g = !0;
            d.forEach(function(c, d) {
                -1 === e && (g = !0, b.forEach(function(b) {
                    g = g && a[b] === c[b]
                }, this), g && (e = d))
            }, this), -1 !== e ? f = d[e] : (b.forEach(function(b) {
                f[b] = a[b]
            }, this), d.push(f), e = d.length - 1), c.forEach(function(c) {
                -1 === b.indexOf(c) && (void 0 === f[c] && (f[c] = []), f[c] = f[c].concat(a[c]))
            }, this), d[e] = f
        }, this), d
    }, dimple._showBarTooltip = function(a, b, c, d) {
        var e, f, g, h, i, j = 5,
            k = 10,
            l = 750,
            m = d3.select(b),
            n = parseFloat(m.attr("x")),
            o = parseFloat(m.attr("y")),
            p = parseFloat(m.attr("width")),
            q = parseFloat(m.attr("height")),
            r = m.attr("opacity"),
            s = m.attr("fill"),
            t = d._dropLineOrigin(),
            u = d3.rgb(d3.rgb(s).r + .6 * (255 - d3.rgb(s).r), d3.rgb(s).g + .6 * (255 - d3.rgb(s).g), d3.rgb(s).b + .6 * (255 - d3.rgb(s).b)),
            v = d3.rgb(d3.rgb(s).r + .8 * (255 - d3.rgb(s).r), d3.rgb(s).g + .8 * (255 - d3.rgb(s).g), d3.rgb(s).b + .8 * (255 - d3.rgb(s).b)),
            w = d.getTooltipText(a),
            x = 0,
            y = 0,
            z = 0;
        null !== c._tooltipGroup && void 0 !== c._tooltipGroup && c._tooltipGroup.remove(), c._tooltipGroup = c.svg.append("g"), i = d._isStacked() ? 1 : p / 2, d.x._hasCategories() || null === t.y || c._tooltipGroup.append("line").attr("x1", n < d.x._origin ? n + i : n + p - i).attr("y1", o < t.y ? o + q : o).attr("x2", n < d.x._origin ? n + i : n + p - i).attr("y2", o < t.y ? o + q : o).style("fill", "none").style("stroke", s).style("stroke-width", 2).style("stroke-dasharray", "3, 3").style("opacity", r).transition().delay(l / 2).duration(l / 2).ease("linear").attr("y2", o < t.y ? t.y - 1 : t.y + 1), i = d._isStacked() ? 1 : q / 2, d.y._hasCategories() || null === t.x || c._tooltipGroup.append("line").attr("x1", n < t.x ? n + p : n).attr("y1", o < d.y._origin ? o + i : o + q - i).attr("x2", n < t.x ? n + p : n).attr("y2", o < d.y._origin ? o + i : o + q - i).style("fill", "none").style("stroke", s).style("stroke-width", 2).style("stroke-dasharray", "3, 3").style("opacity", r).transition().delay(l / 2).duration(l / 2).ease("linear").attr("x2", n < t.x ? t.x - 1 : t.x + 1), e = c._tooltipGroup.append("g"), f = e.append("rect").attr("class", "dimple-tooltip"), e.selectAll(".dimple-dont-select-any").data(w).enter().append("text").attr("class", "dimple-tooltip").text(function(a) {
            return a
        }).style("font-family", d.tooltipFontFamily).style("font-size", d._getTooltipFontSize()), e.each(function() {
            y = this.getBBox().width > y ? this.getBBox().width : y, z = this.getBBox().width > z ? this.getBBox().height : z
        }), e.selectAll("text").attr("x", 0).attr("y", function() {
            return x += this.getBBox().height, x - this.getBBox().height / 2
        }), f.attr("x", -j).attr("y", -j).attr("height", Math.floor(x + j) - .5).attr("width", y + 2 * j).attr("rx", 5).attr("ry", 5).style("fill", v).style("stroke", u).style("stroke-width", 2).style("opacity", .95), n + p + j + k + y < parseFloat(c.svg.node().getBBox().width) ? (g = n + p + j + k, h = o + q / 2 - (x - (z - j)) / 2) : n - (j + k + y) > 0 ? (g = n - (j + k + y), h = o + q / 2 - (x - (z - j)) / 2) : o + q + x + k + j < parseFloat(c.svg.node().getBBox().height) ? (g = n + p / 2 - (2 * j + y) / 2, g = g > 0 ? g : k, g = g + y < parseFloat(c.svg.node().getBBox().width) ? g : parseFloat(c.svg.node().getBBox().width) - y - k, h = o + q + 2 * j) : (g = n + p / 2 - (2 * j + y) / 2, g = g > 0 ? g : k, g = g + y < parseFloat(c.svg.node().getBBox().width) ? g : parseFloat(c.svg.node().getBBox().width) - y - k, h = o - x - (z - j)), e.attr("transform", "translate(" + g + " , " + h + ")")
    }, dimple._showPointTooltip = function(a, b, c, d) {
        var e, f, g, h, i = 5,
            j = 10,
            k = 750,
            l = d3.select(b),
            m = parseFloat(l.attr("cx")),
            n = parseFloat(l.attr("cy")),
            o = parseFloat(l.attr("r")),
            p = dimple._helpers.opacity(a, c, d),
            q = l.attr("stroke"),
            r = d._dropLineOrigin(),
            s = d3.rgb(d3.rgb(q).r + .6 * (255 - d3.rgb(q).r), d3.rgb(q).g + .6 * (255 - d3.rgb(q).g), d3.rgb(q).b + .6 * (255 - d3.rgb(q).b)),
            t = d3.rgb(d3.rgb(q).r + .8 * (255 - d3.rgb(q).r), d3.rgb(q).g + .8 * (255 - d3.rgb(q).g), d3.rgb(q).b + .8 * (255 - d3.rgb(q).b)),
            u = 0,
            v = 0,
            w = 0,
            x = d.getTooltipText(a);
        null !== c._tooltipGroup && void 0 !== c._tooltipGroup && c._tooltipGroup.remove(), c._tooltipGroup = c.svg.append("g"), c._tooltipGroup.append("circle").attr("cx", m).attr("cy", n).attr("r", o).attr("opacity", 0).style("fill", "none").style("stroke", q).style("stroke-width", 1).transition().duration(k / 2).ease("linear").attr("opacity", 1).attr("r", o + d.lineWeight + 2).style("stroke-width", 2), null !== r.y && c._tooltipGroup.append("line").attr("x1", m).attr("y1", n < r.y ? n + o + d.lineWeight + 2 : n - o - d.lineWeight - 2).attr("x2", m).attr("y2", n < r.y ? n + o + d.lineWeight + 2 : n - o - d.lineWeight - 2).style("fill", "none").style("stroke", q).style("stroke-width", 2).style("stroke-dasharray", "3, 3").style("opacity", p).transition().delay(k / 2).duration(k / 2).ease("linear").attr("y2", n < r.y ? r.y - 1 : r.y + 1), null !== r.x && c._tooltipGroup.append("line").attr("x1", m < r.x ? m + o + d.lineWeight + 2 : m - o - d.lineWeight - 2).attr("y1", n).attr("x2", m < r.x ? m + o + d.lineWeight + 2 : m - o - d.lineWeight - 2).attr("y2", n).style("fill", "none").style("stroke", q).style("stroke-width", 2).style("stroke-dasharray", "3, 3").style("opacity", p).transition().delay(k / 2).duration(k / 2).ease("linear").attr("x2", m < r.x ? r.x - 1 : r.x + 1), e = c._tooltipGroup.append("g"), f = e.append("rect").attr("class", "dimple-tooltip"), e.selectAll(".dont-select-any").data(x).enter().append("text").attr("class", "dimple-tooltip").text(function(a) {
            return a
        }).style("font-family", d.tooltipFontFamily).style("font-size", d._getTooltipFontSize()), e.each(function() {
            v = this.getBBox().width > v ? this.getBBox().width : v, w = this.getBBox().width > w ? this.getBBox().height : w
        }), e.selectAll("text").attr("x", 0).attr("y", function() {
            return u += this.getBBox().height, u - this.getBBox().height / 2
        }), f.attr("x", -i).attr("y", -i).attr("height", Math.floor(u + i) - .5).attr("width", v + 2 * i).attr("rx", 5).attr("ry", 5).style("fill", t).style("stroke", s).style("stroke-width", 2).style("opacity", .95), m + o + i + j + v < parseFloat(c.svg.node().getBBox().width) ? (g = m + o + i + j, h = n - (u - (w - i)) / 2) : m - o - (i + j + v) > 0 ? (g = m - o - (i + j + v), h = n - (u - (w - i)) / 2) : n + o + u + j + i < parseFloat(c.svg.node().getBBox().height) ? (g = m - (2 * i + v) / 2, g = g > 0 ? g : j, g = g + v < parseFloat(c.svg.node().getBBox().width) ? g : parseFloat(c.svg.node().getBBox().width) - v - j, h = n + o + 2 * i) : (g = m - (2 * i + v) / 2, g = g > 0 ? g : j, g = g + v < parseFloat(c.svg.node().getBBox().width) ? g : parseFloat(c.svg.node().getBBox().width) - v - j, h = n - u - (w - i)), e.attr("transform", "translate(" + g + " , " + h + ")")
    }, dimple.filterData = function(a, b, c) {
        var d = a;
        return null !== b && null !== c && (null !== c && void 0 !== c && (c = [].concat(c)), d = [], a.forEach(function(a) {
            null === a[b] ? d.push(a) : c.indexOf([].concat(a[b]).join("/")) > -1 && d.push(a)
        }, this)), d
    }, dimple.getUniqueValues = function(a, b) {
        var c = [];
        return null !== b && void 0 !== b && (b = [].concat(b), a.forEach(function(a) {
            var d = "";
            b.forEach(function(b, c) {
                c > 0 && (d += "/"), d += a[b]
            }, this), -1 === c.indexOf(d) && c.push(d)
        }, this)), c
    }, dimple.newSvg = function(a, b, c) {
        var d = null;
        if ((null === a || void 0 === a) && (a = "body"), d = d3.select(a), d.empty()) throw "The '" + a + "' selector did not match any elements.  Please prefix with '#' to select by id or '.' to select by class";
        return d.append("svg").attr("width", b).attr("height", c)
    }
}();