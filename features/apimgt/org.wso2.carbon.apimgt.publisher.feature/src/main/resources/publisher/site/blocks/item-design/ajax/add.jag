<%
include("/jagg/jagg.jag");
var log = new Log();
var encode = require('encode');
encode = new encode.Encode();
var CryptoUtil = Packages.org.wso2.carbon.core.util.CryptoUtil;
var SwaggerParser = Packages.io.swagger.parser.SwaggerParser;

function loadSwaggerObj(path)
{
    var obj, file = new File(path);
    if(file.isExists()){
        obj = require(path);
    } else {
        obj = require("/site/blocks/item-design/ajax/default_swagger.json");
    }
    return obj;
}

function isPositiveInteger(s) {
    return !!s.match(/^[0-9]+$/);
}

function getSwaggerError(errorsList) {
    var errorCount = errorsList.size();
    var errorMsg = "<ol>" ;
    var count = 0;
    for (count = 0; count < errorCount; count++) {
        errorMsg = errorMsg + "<li>" + errorsList.get(count) + "</li>";
    }
    errorMsg = errorMsg + "</ol></div>";
    return errorMsg;
}

var parseSwaggerDefinition = function (swagger) {
    var swaggerJson = {};
    try {
        swaggerJson = JSON.parse(swagger);
    } catch (e) {
        //fail-over to validate yaml based definitions
        try {
            var DeserializationUtils = Packages.io.swagger.parser.util.DeserializationUtils;
            var swaggerJsonNode = DeserializationUtils.readYamlTree(swagger).toString();
            swaggerJson = JSON.parse(swaggerJsonNode);
        } catch (e) {
            print({error: true, message: source + " contains an invalid Swagger Definition"});
            return;
        }
    }
    return swaggerJson;
}

if(jagg.isCSRFTokenValid())
(function () {
    response.contentType = "text/plain; charset=UTF-8";
    response.addHeader('Cache-Control','no-cache, no-store, must-revalidate'); // HTTP 1.1.
    response.addHeader('Pragma','no-cache'); // HTTP 1.0.
    response.addHeader('Expires','0');
    var mod, obj, result, username,
	action = request.getParameter("action"),
    site = require("/site/conf/site.json"),
    msg = require("/site/conf/ui-messages.jag"),
    parser = new SwaggerParser(),
    supportedSwaggerVersion = "2.0",
    supportedOpenAPIVersion = "3.0.0",
    supportedHTTPMethods = ["get", "put", "post", "delete", "patch", "head", "options"];

    if(jagg.getUser() == null){
        print({
            error:true,
            message:'timeout'
        });
    }else{
        if (request.getMethod() == 'POST' && (action === "start")) {
            var l = new Log();
            var type = request.getParameter("type");
            var swagger = null;
            var wsdl = null;
            var wsdlFile = null;
            var apiDefinitionVersion = request.getParameter("apiDefinitionVersion");

            if(type == "rest"){
                var url = request.getParameter("swagger-url");
                var file = request.getFile("swagger-file");
                var import_type = request.getParameter("import-definition");
                if(import_type == "swagger-url" && url){
                    url = url.trim();
                    var data = {};
                    try {
                        var content = get(url, data);
                        swagger = content.data;
                        //Manually parsing api definition for json/yaml, since SwaggerParser 3.x has not been
                        //released yet.
                        var apiDefinition = parseSwaggerDefinition(swagger);
                        if (apiDefinition.openapi) {
                            if (apiDefinition.openapi != supportedOpenAPIVersion) {
                                print({
                                    error: true,
                                    message: "Unsupported OpenAPI version provided. Please re-import with OpenAPI " +
                                    supportedOpenAPIVersion
                                });
                                return;
                            }

                            if (apiDefinition.info == null || apiDefinition.paths == null) {
                                print({error: true, message: url + " is not a valid Swagger Definition url"});
                                return;
                            }
                        } else if (apiDefinition.swagger) {
                            var swaggerDeserializationResult = parser.readWithInfo(swagger);
                            var swaggerObj = swaggerDeserializationResult.getSwagger();
                            var swaggerErrors = swaggerDeserializationResult.getMessages();

                            //Supported swagger version check
                            if (swaggerObj.swagger != supportedSwaggerVersion) {
                                print({
                                    error: true,
                                    message: "Unsupported swagger version provided. Please re-import with swagger " + supportedSwaggerVersion
                                });
                                return;
                            }
                            //Validate swagger definition with mandatory swagger elements
                            if (swaggerErrors.size() > 0) {
                                errorMsg = getSwaggerError(swaggerErrors);
                                print({
                                    error: true,
                                    message: "<div><div> Input URL contains an invalid swagger definition." + "</div>" +
                                    errorMsg
                                });
                                return;
                            }
                        } else {
                            print({error: true, message: "Input URL contains an invalid swagger definition."});
                            return;
                        }

                    } catch (e) {
                        print({error: true, message: "Input URL contains an invalid swagger definition."});
                        return;
                    }
                }
                else if(import_type == "swagger-file" && file){
                    try {
                        file.open("r");
                        swagger = file.readAll();
                        file.close();

                        //Manually parsing api definition for json/yaml, since SwaggerParser 3.x has not been
                        //released yet.
                        var apiDefinition = parseSwaggerDefinition(swagger);
                        if (apiDefinition.openapi) {

                            //Supported Open API Version check
                            if (apiDefinition.openapi != supportedOpenAPIVersion) {
                                print({
                                    error: true,
                                    message: "Unsupported OpenAPI version provided. Please re-import with OpenAPI " +
                                    supportedOpenAPIVersion
                                });
                                return;
                            }

                            if (apiDefinition.info == null || apiDefinition.paths == null) {
                                print({
                                    error: true,
                                    message: file.getName() + " is not a valid Swagger Definition file"
                                });
                                return;
                            }
                        } else if (apiDefinition.swagger) {

                            var swaggerDeserializationResult = parser.readWithInfo(swagger);
                            var swaggerObj = swaggerDeserializationResult.getSwagger();
                            var swaggerErrors = swaggerDeserializationResult.getMessages();

                            //Supported swagger version check
                            if (swaggerObj.swagger != supportedSwaggerVersion) {
                                print({
                                    error: true,
                                    message: "Unsupported swagger version provided. Please re-import with swagger " + supportedSwaggerVersion
                                });
                                return;
                            }
                            //Validate swagger definition with mandatory swagger elements
                            if (swaggerErrors.size() > 0) {
                                errorMsg = getSwaggerError(swaggerErrors);
                                print({
                                    error: true,
                                    message: "<div><div>" + file.getName() + " contains an invalid swagger definition." + "</div>" + errorMsg
                                });
                                return;
                            }
                        } else {
                            print({error: true, message: file.getName() + " contains an invalid swagger definition."});
                            return;
                        }
                    } catch (e) {
                        print({error: true, message: file.getName() + " contains an invalid swagger definition."});
                        return;
                    }
                } else {
                    var obj = require("/site/blocks/item-design/ajax/default_swagger.json");
                    swagger = stringify(obj);
                }
            }
            else if(type == "soap"){
                var url = request.getParameter("wsdl-url");
                wsdlFile = request.getFile("wsdl-file");
                var import_type = request.getParameter("import-definition");
                var passThrough = request.getParameter("soap-options-pass-thru");
                var rest = request.getParameter("soap-options-rest");
                wsdl = "soap";
                if (wsdlFile) {
                    wsdl = wsdlFile.getName();
                }
                if(url){
                    wsdl = url.trim();
                }
                var obj = loadSwaggerObj("/site/conf/soap_swagger.json");
                swagger = stringify(obj);
                var resp;
                try {
                    if(rest) {
                        var soapToRestUtil = Packages.org.wso2.carbon.apimgt.impl.soaptorest.util.SOAPOperationBindingUtils;
                        resp = new Packages.java.lang.String(soapToRestUtil.getSoapOperationMapping(url));
                        if(resp) {
                            mappingJson = JSON.parse(resp);
                            session.put("mappingJson", mappingJson);
                            var names={},parameters=[];
                            var definitions = {};
                            for(var i = 0; i < mappingJson.length; i++) {
                                var responses = {},verb={},status={},description={},definition={};
                                var httpverb = mappingJson[i].httpVerb.toLowerCase();
                                var path = "/" + mappingJson[i].name;
                                description["description"] = "";
                                status["200"] = description;
                                responses.tags = [];
                                responses.parameters = [];
                                responses["responses"]=status;
                                responses.tags.push(mappingJson[i].name);
                                var count = 0;
                                var properties = {};
                                for(var j = 0; j < mappingJson[i].parameters.length; j++) {
                                    var parameter = {};
                                    parameter.description = "";
                                    var type = mappingJson[i].parameters[j].dataType;
                                    var isArray = mappingJson[i].parameters[j].isArray;
                                    if(mappingJson[i].parameters[j].isComplexType) {
                                        if(count == 0) {
                                            parameter.in = "body";
                                            parameter.name = "Payload";
                                            var def = "#/definitions/" + mappingJson[i].name;
                                            var ref = {}, typeObj = {};
                                            ref["$ref"] = def;
                                            typeObj["type"] = "object";
                                            parameter.schema = ref;

                                            var defN = "#/definitions/" + mappingJson[i].parameters[j].name;
                                            var refN = {}, typeNObj = {};
                                            refN["$ref"] = defN;
                                            typeNObj["type"] = "object";

                                            if(!definitions[mappingJson[i].name])
                                                definitions[mappingJson[i].name] = {};
                                            if(!definitions[mappingJson[i].parameters[j].name])
                                                definitions[mappingJson[i].parameters[j].name] = {};
                                            definitions[mappingJson[i].name] = typeObj;
                                            definitions[mappingJson[i].parameters[j].name] = typeNObj;
                                            var bodyParam = {};
                                            bodyParam[mappingJson[i].parameters[j].name] = refN;
                                            definitions[mappingJson[i].name].properties = bodyParam;
                                        }
                                        var property = {};
                                        property.type = type;
                                        if(isArray) {
                                            property.type = "array";
                                            var itemType = {};
                                            itemType["type"] = type;
                                            property.items = itemType;
                                            properties[mappingJson[i].parameters[j].name] = property;
                                        } else {
                                            var root;
                                            var buildTree = function(obj, parent) {
                                                for(var k in obj) {
                                                    if(obj[k].wsdlComplexType && obj[k].wsdlComplexType.paramList) {
                                                        root = parent;
                                                        buildTree(obj[k].wsdlComplexType.paramList,obj[k]);
                                                    } else {
                                                        if(!definitions[mappingJson[i].parameters[j].name])
                                                            definitions[mappingJson[i].parameters[j].name] = {};

                                                        if(root && root.name && parent.name) {
                                                            var rootDef = "#/definitions/" + root.name;
                                                            var parentDef = "#/definitions/" + parent.name;
                                                            if(!definitions[mappingJson[i].parameters[j].name].properties) {
                                                                definitions[mappingJson[i].parameters[j].name].properties = {};
                                                                definitions[mappingJson[i].parameters[j].name].properties[root.name] = {};
                                                                definitions[mappingJson[i].parameters[j].name].properties[root.name]["$ref"] = rootDef;
                                                            }
                                                            if(!definitions[root.name]) {
                                                                definitions[root.name] = {};
                                                                definitions[root.name].type = "object";
                                                                definitions[root.name].properties = {}
                                                            }
                                                            if(!definitions[parent.name]) {
                                                                definitions[parent.name] = {};
                                                                definitions[parent.name].type = "object";
                                                                definitions[parent.name].properties = {};
                                                            }
                                                            if(parent.name != root.name) {
                                                                if(!definitions[root.name].properties[parent.name]) {
                                                                    definitions[root.name].properties[parent.name] = {};
                                                                }
                                                                if(!definitions[root.name].properties[parent.name]["$ref"]) {
                                                                    definitions[root.name].properties[parent.name]["$ref"] = {};
                                                                    definitions[root.name].properties[parent.name]["$ref"] = parentDef;
                                                                }
                                                            }
                                                            if(!definitions[parent.name].properties[obj[k].name]) {
                                                                if(obj[k].isArray) {
                                                                    definitions[parent.name].type = 'array';
                                                                    definitions[parent.name].items = {};
                                                                    definitions[parent.name].items.type = obj[k].dataType;
                                                                } else {
                                                                    definitions[parent.name].properties[obj[k].name] = {};
                                                                    if(obj[k].dataType == 'int') {
                                                                        definitions[parent.name].properties[obj[k].name].type = 'integer';
                                                                    } else {
                                                                        definitions[parent.name].properties[obj[k].name].type = obj[k].dataType;
                                                                    }
                                                                    if(parent.name != root.name) {
                                                                        definitions[parent.name].properties[obj[k].name]["x-path"] = root.name + "/" + parent.name + "/" + obj[k].name;
                                                                    } else {
                                                                        definitions[parent.name].properties[obj[k].name]["x-path"] = parent.name + "/" + obj[k].name;
                                                                    }
                                                                }
                                                            }

                                                        } else if(parent.name) {
                                                            var parentDef = "#/definitions/" + parent.name;
                                                            if(!definitions[parent.name]) {
                                                                definitions[parent.name] = {};
                                                                definitions[parent.name].type = "object";
                                                                definitions[parent.name].properties = {};
                                                            }
                                                            if(!definitions[parent.name].properties[obj[k].name]) {
                                                                if(obj[k].isArray) {
                                                                    definitions[parent.name].type = 'array';
                                                                    definitions[parent.name].items = {};
                                                                    definitions[parent.name].items.type = obj[k].dataType;
                                                                } else {
                                                                    definitions[parent.name].properties[obj[k].name] = {};
                                                                    if(obj[k].dataType == 'int') {
                                                                        definitions[parent.name].properties[obj[k].name].type = 'integer';
                                                                    } else {
                                                                        definitions[parent.name].properties[obj[k].name].type = obj[k].dataType;
                                                                    }
                                                                    definitions[parent.name].properties[obj[k].name]["x-path"] = mappingJson[i].parameters[j].name + "/" + parent.name + "/" + obj[k].name;
                                                                }
                                                            }
                                                            if(!definitions[mappingJson[i].parameters[j].name].properties) {
                                                                definitions[mappingJson[i].parameters[j].name].properties = {};
                                                            }
                                                            if(!definitions[mappingJson[i].parameters[j].name].properties[parent.name]) {
                                                                definitions[mappingJson[i].parameters[j].name].properties[parent.name] = {};
                                                                definitions[mappingJson[i].parameters[j].name].properties[parent.name]["$ref"] = {};
                                                            }
                                                            definitions[mappingJson[i].parameters[j].name].properties[parent.name]["$ref"] = parentDef;

                                                        } else {
                                                            if(obj[k].isArray) {
                                                                definitions[mappingJson[i].parameters[j].name].type = 'array';
                                                                definitions[mappingJson[i].parameters[j].name].items = {};
                                                                definitions[mappingJson[i].parameters[j].name].items.type = obj[k].dataType;
                                                            } else {
                                                                if(!definitions[mappingJson[i].parameters[j].name].properties) {
                                                                    definitions[mappingJson[i].parameters[j].name].properties = {};
                                                                }
                                                                if(!definitions[mappingJson[i].parameters[j].name].properties[obj[k].name]) {
                                                                    definitions[mappingJson[i].parameters[j].name].properties[obj[k].name] = {};
                                                                }
                                                                if(obj[k].dataType == 'int') {
                                                                    definitions[mappingJson[i].parameters[j].name].properties[obj[k].name].type = 'integer';
                                                                } else {
                                                                    definitions[mappingJson[i].parameters[j].name].properties[obj[k].name].type = obj[k].dataType;
                                                                }
                                                                definitions[mappingJson[i].parameters[j].name].properties[obj[k].name]["x-path"] = mappingJson[i].parameters[j].name + "/" + obj[k].name;
                                                            }
                                                        }
                                                    }
                                                }
                                            };
                                            buildTree(mappingJson[i].parameters[j].wsdlComplexType.paramList,
                                                    mappingJson[i].parameters[j].wsdlComplexType.paramList);
                                        }
                                        //definitions[mappingJson[i].parameters[j].name].properties = properties;
                                        count++;
                                    } else {
                                        parameter.in = "query";
                                        parameter.name = mappingJson[i].parameters[j].name;
                                        parameter.type = type;
                                    }

                                    if(parameter.in) {
                                        parameters.push(parameter);
                                        responses.parameters.push(parameter);
                                    }
                                }
                                verb[httpverb]=responses;
                                names[path]=verb;
                            }
                            session.put("paths", names);
                            session.put("definitions", definitions);
                        } else {
                            log.error("error occurred while soap to rest conversion.")
                        }
                    } else {
                        session.remove("paths");
                    }
                } catch (e) {
                    log.error(e);
                }
            } else if (type == "ws") {
                session.put("wsdl", null);
                session.put("swagger", null);
                session.put("ws", "ws");
            } else if (type == "new") {
                session.put("ws", null);
                session.put("wsdl", null);
                session.put("swagger", null);
                session.put("apiDefinitionVersion", apiDefinitionVersion);
            }
            if (swagger) {
                session.put("ws", null);
                session.put("wsdl", null);
                session.put("swagger", swagger);
            }
            if (wsdl) {
                session.put("ws", null);
                session.put("swagger", swagger);
                session.put("wsdl", wsdl);
            }
            if (wsdlFile) {
                session.put("ws", null);
                session.put("swagger", swagger);
                session.put("wsdl-file", wsdlFile);
            } else {
                session.remove("wsdl-file");
            }

            print({
                error: false,
                message: 'imported'
            });

        }else if (request.getMethod() == 'POST' && (action === "design")) {
            mod = jagg.module("api");
            var apiData = {};
            apiData.apiName = request.getParameter("name", "UTF-8");
            apiData.name = request.getParameter("name", "UTF-8");
            apiData.version = request.getParameter("version");
            apiData.type = request.getParameter("type");
            if (request.getParameter("provider") == null) {
            	apiData.provider = jagg.getUser().username;
            } else {
            	apiData.provider = request.getParameter("provider");
            }
            var apiId = {
                apiName : request.getParameter("name", "UTF-8"),
                version : request.getParameter("version"),
                provider: apiData.provider
            };
            apiData.context = request.getParameter("context","UTF-8");
            apiData.imageUrl = request.getFile("apiThumb");

            //validate uploaded image
            if(apiData.imageUrl != null &&!jagg.isValiedImage(apiData.imageUrl)){
                obj = {
                    error:true,
                    message:"Please upload a valid image file for the API icon."
                };
                print(obj);
                return;
            }

            var wsdlFile = request.getFile("wsdl-file");
            if (wsdlFile == null) {
                wsdlFile = session.get("wsdl-file");
            }

            //try to read the wsdl content from the url
            var wsdlUrl = request.getParameter("wsdl");
            if (wsdlFile == null && wsdlUrl != null) {
                if (!wsdlUrl.match(org.wso2.carbon.apimgt.impl.APIConstants.API_WSDL_RESOURCE_LOCATION)) {
                    try {
                        org.wso2.carbon.apimgt.impl.utils.APIUtil.isWSDL2Document(wsdlUrl);
                    } catch (e) {
                        obj = {
                            error:true,
                            message:"Please enter a valid WSDL URL"
                        };
                        print(obj);
                        return;
                    }
                }
            }

            //If API not exist create
            result = mod.checkIfResourceExists(apiData);
            if (!result) {
                // Check logged in user try to create api with different user name.
                if (jagg.getUser().username != apiData.provider) {
                    obj = {
                        error:true,
                        message:"Not allowed to add APIs with different provider name other than logged in user."
                    };
                    print(obj);
                    return;
                }
                result = mod.createAPI(apiData);
                if (result.error==true) {
                    obj = {
                        error:true,
                        message:result.message
                    };
                    print(obj);
                    return;
                }
            }

            apiData.description = request.getParameter("description","UTF-8");
            apiData.tags = request.getParameter("tags","UTF-8");
            apiData.bizOwner = request.getParameter("bizOwner","UTF-8");
            apiData.bizOwnerEmail = request.getParameter("bizOwnerMail","UTF-8");
            apiData.techOwner = request.getParameter("techOwner","UTF-8");
            apiData.techOwnerEmail = request.getParameter("techOwnerMail","UTF-8");
            apiData.visibility = request.getParameter("visibility");
            apiData.visibleRoles = request.getParameter("roles","UTF-8");
            apiData.wsdl = request.getParameter("wsdl");
            apiData.wsdlFile = wsdlFile;
            apiData.accessControl = request.getParameter("accessControl");
            apiData.accessControlRoles = request.getParameter("accessControlRoles", "UTF-8");
            apiData.additionalProperties = request.getParameter("additionalProperties", "UTF-8");

            apiData.swagger = request.getParameter("swagger", "UTF-8");

            result = mod.updateAPIDesign(apiData);
            if(apiData.wsdl) {
                var swag = parse(apiData.swagger);
                var isSoapToRestApi = true;
                if(swag.paths["/*"]) {
                    isSoapToRestApi = false;
                }
                if(isSoapToRestApi) {
                    mappingJson = session.get("mappingJson");
                    if (mappingJson) {
                        var sequenceGenerator = Packages.org.wso2.carbon.apimgt.impl.soaptorest.SequenceGenerator;
                        sequenceGenerator.generateSequences(stringify(apiData), stringify(mappingJson));
                    }
                }
            }
            if (result.error == true) {
                obj = {
                    error:true,
                    message:result.message
                };
            } else {
                obj = {
                    error:false,
                    data :apiId
                }
            }
            print(obj);

        } else if (request.getMethod() == 'POST' && action === "implement") {
            mod = jagg.module("api");
            var apiData = {};
            apiData.apiName = request.getParameter("name", "UTF-8");
            apiData.version = request.getParameter("version");
            apiData.provider= request.getParameter("provider");
            var apiId = {
                apiName : request.getParameter("name", "UTF-8"),
                version : request.getParameter("version"),
                provider: request.getParameter("provider")
            };
            apiData.context = request.getParameter("context","UTF-8");

            var endpointType = request.getParameter("endpoint_type");

            if(endpointType == "default") {
                if(!(request.getParameter("inSequence")) || (request.getParameter("inSequence") == "none"))  {
                    obj = {
                           error:true,
                           message:"You must upload or select a message mediation In Flow policy",
                           data :apiId,
                       };
                   print(obj);
                   return;
                }
            }

            apiData.implementation_type = request.getParameter("implementation_methods");
            apiData.wsdl = request.getParameter("wsdl");
            apiData.wadl = request.getParameter("wadl");
            apiData.endpointSecured = request.getParameter("endpointType");
            apiData.endpointAuthDigest = request.getParameter("endpointAuthType");
            apiData.endpointUTUsername = request.getParameter("epUsername");
            var apiBackendPassword = request.getParameter("epPassword");
            if (apiBackendPassword != null && apiBackendPassword != "" && apiBackendPassword != "*****") {
             apiData.endpointUTPassword = apiBackendPassword;
             var inputString = apiBackendPassword;
             var byteArray = [];
             for (var i = 0; i < inputString.length; ++i) {
               byteArray.push(inputString.charCodeAt(i));
             }

             try {
                 var base64EncodedEncryptedPassword = CryptoUtil.getDefaultCryptoUtil().encryptAndBase64Encode(byteArray);
                 session.put(request.getParameter("name", "UTF-8") + "-" + request.getParameter("version") +
                        "-epPassword", base64EncodedEncryptedPassword);
             } catch (e) {
                 log.error(e);
                 obj = {
                     error:true,
                     message:"Error occurred while encrypting the password"
                 };
                 print(obj);
                 return;
             }

            } else if (apiBackendPassword == "*****") {
             var encryptedPasswordFromSession = session.get(request.getParameter("name", "UTF-8") + "-" +
                                                                request.getParameter("version") + "-epPassword");
             var byteArray = CryptoUtil.getDefaultCryptoUtil().base64DecodeAndDecrypt(encryptedPasswordFromSession);
             var decodedPassword = "";
             for(var index = 0; index < byteArray.length; index += 1) {
                   decodedPassword += String.fromCharCode(byteArray[index]);
             }
             apiData.endpointUTPassword = decodedPassword.toString();
            } else {
             apiData.endpointUTPassword = session.get(request.getParameter("name", "UTF-8") + "-" +
                                                                request.getParameter("version") + "-epPassword");
            }
            apiData.endpoint_config= request.getParameter("endpoint_config","UTF-8");
            apiData.destinationStats= request.getParameter("destinationStats","UTF-8");

            apiData.swagger = request.getParameter("swagger", "UTF-8");
            apiData.inSequence = request.getParameter("inSequence");
            apiData.outSequence= request.getParameter("outSequence");
            apiData.faultSequence = request.getParameter("faultSequence");
            apiData.inSeqFile = request.getFile("inSeqFile");
            apiData.outSeqFile = request.getFile("outSeqFile");
            apiData.corsConfiguration=request.getParameter("corsConfiguration","UTF-8");

            var soapToRestInsequences = request.getParameter("sequenceMapping");
            var soapToRestOutsequences = request.getParameter("sequenceOutMapping");

            if(soapToRestInsequences && soapToRestOutsequences) {
                var sequenceUtils = Packages.org.wso2.carbon.apimgt.impl.soaptorest.util.SequenceUtils;
                sequenceUtils.updateRestToSoapConvertedSequences(apiData.apiName, apiData.version, apiData.provider, "in", soapToRestInsequences);
                sequenceUtils.updateRestToSoapConvertedSequences(apiData.apiName, apiData.version, apiData.provider, "out", soapToRestOutsequences);
            }

            result = mod.updateAPIImplementation(apiData);
            if (result.error==true) {
                obj = {
                    error:true,
                    message:encode.forHtml(result.message),
                    data :apiId,
                };
            } else {
                obj = {
                    error:false,
                    data :apiId,
                }
            }
            print(obj);
        }   else if (request.getMethod() == 'POST' && action === "manage") {
            mod = jagg.module("api");
            var apiData = {};
            apiData.apiName = request.getParameter("name", "UTF-8");
            apiData.version = request.getParameter("version");
            apiData.provider= request.getParameter("provider");
            var apiId = {
                apiName : request.getParameter("name", "UTF-8"),
                version : request.getParameter("version"),
                provider: request.getParameter("provider")
            };
            apiData.context = request.getParameter("context","UTF-8");
            apiData.defaultVersion=request.getParameter("default_version_checked");


            apiData.swagger = request.getParameter("swagger", "UTF-8");
            apiData.tier = request.getParameter("tiersCollection");
            var enableApiLevelPolicy = request.getParameter("enableApiLevelPolicy");
            if(enableApiLevelPolicy != null && "true" == enableApiLevelPolicy) {
                apiData.apiPolicy = request.getParameter("apiTier");
            } else {
                apiData.apiPolicy = null;
            }
            if(request.getParameter("transport_http") == null && request.getParameter("transport_https") == null)   {
                apiData.transports = null;
            } else if(request.getParameter("transport_http") != null && request.getParameter("transport_https") != null) {
                apiData.transports=request.getParameter("transport_http")+","+request.getParameter("transport_https");
            }   else if(request.getParameter("transport_http") != null){
        	apiData.transports=request.getParameter("transport_http");
            }   else    {
        	    apiData.transports=request.getParameter("transport_https");
            }

            apiData.responseCache = request.getParameter("responseCache","UTF-8");
            apiData.subscriptionAvailability = request.getParameter("subscriptions");
            apiData.subscriptionTenants = request.getParameter("tenants","UTF-8");
            apiData.bizOwner = request.getParameter("bizOwner", "UTF-8");
            apiData.bizOwnerMail = request.getParameter("bizOwnerMail", "UTF-8");
            apiData.techOwner = request.getParameter("techOwner", "UTF-8");
            apiData.techOwnerMail = request.getParameter("techOwnerMail", "UTF-8");

            apiData.responseCache = request.getParameter("responseCache","UTF-8");
            apiData.cacheTimeout= request.getParameter("cacheTimeout","UTF-8");
            apiData.destinationStats= request.getParameter("destinationStats","UTF-8");
		    apiData.environments = request.getParameter("environments");
            apiData.productionTps = request.getParameter("productionTps");
            apiData.sandboxTps = request.getParameter("sandboxTps");
            apiData.corsConfiguration=request.getParameter("corsConfiguration","UTF-8");
            apiData.additionalProperties = request.getParameter("additionalProperties", "UTF-8");
            apiData.authorizationHeader = request.getParameter("authorizationHeader");
            apiData.gatewayLabels = request.getParameter("gatewayLabels", "UTF-8");
            var errorMsg = null;
            if(apiData.productionTps != null && apiData.productionTps != ""  && !isPositiveInteger(apiData.productionTps)){
                errorMsg = "Invalid input for Production TPS";
            }

            if(apiData.sandboxTps != null && apiData.sandboxTps != "" && !isPositiveInteger(apiData.sandboxTps)){
                errorMsg = "Invalid input for Sandbox TPS";
            }

            if(errorMsg != null){
             obj = {
                    error:true,
                    message:errorMsg,
                    data :apiId,
                };
            print(obj);
            return;
            }

            result = mod.manageAPI(apiData);
            if (result.error==true) {
                obj = {
                    error:true,
                    message:result.message,
                    data :apiId,
                };
            } else {
                obj = {
                    error:false,
                    data :apiId,
                }
            }
            print(obj);
        }  else if (request.getMethod() == 'POST' && action === "uploadSequence") {
            mod = jagg.module("api");
            var apiData = {};
            apiData.apiName = request.getParameter("name", "UTF-8");
            apiData.version = request.getParameter("version");
            apiData.provider= request.getParameter("provider");
            var apiId = {
                apiName : request.getParameter("name", "UTF-8"),
                version : request.getParameter("version"),
                provider: request.getParameter("provider")
            };
            apiData.seqFile = request.getFile("file");
            apiData.seqType= request.getParameter("seqType");
            result = mod.uploadSequenceFile(apiData);

            if (result.error==true) {
                obj = {
                    error:true,
                    message:result.message,
                    data :apiId,
                };
            } else {
                obj = {
                    error:false,
                    data :apiId,
                    fileName:result
                }
            }
            print(obj);

    	} else if (action === "swagger") {
            mod = jagg.module("api");
            var apiData = {};
            apiData.apiName = request.getParameter("name", "UTF-8");
            apiData.version = request.getParameter("version");
            if (request.getParameter("provider") == null) {
            	apiData.provider = jagg.getUser().username;
            } else {
            	apiData.provider = request.getParameter("provider")
            }
            var data = mod.getOpenAPIDefinitionResource(apiData);
            print(data.swagger);
        }   else if (request.getMethod() == 'POST' && (action === "sampleDesign")) {
            mod = jagg.module("api");
            var apiData = {};
            apiData.apiName = request.getParameter("name", "UTF-8");
            apiData.name = request.getParameter("name", "UTF-8");
            apiData.version = request.getParameter("version");
            apiData.type = request.getParameter("type");
            if (request.getParameter("provider") == null) {
            	apiData.provider = jagg.getUser().username;
            } else {
            	apiData.provider = request.getParameter("provider")
            }
            var apiId = {
                apiName : request.getParameter("name", "UTF-8"),
                version : request.getParameter("version"),
                provider: apiData.provider
            };
            apiData.context = request.getParameter("context","UTF-8");
            apiData.imageURL = request.getParameter("apiThumb","UTF-8");
            var file = new File(apiData.imageURL);
            file.open("r");
            apiData.imageUrl = file;

            //validate uploaded image
            if(apiData.imageUrl != null &&!jagg.isValiedImage(apiData.imageUrl)){
                obj = {
                    error:true,
                    message:"Please upload a valid image file for the API icon."
                };
                print(obj);
                return;
            }


            //If API not exist create
            result = mod.checkIfResourceExists(apiData);
            if(!result){
                result = mod.createAPI(apiData);
                if (result.error==true) {
                    obj = {
                        error:true,
                        message:result.message
                    };
                    print(obj);
                    return;
                }
            }

            apiData.description = request.getParameter("description","UTF-8");
            apiData.tags = request.getParameter("tags","UTF-8");
            apiData.bizOwner = request.getParameter("bizOwner","UTF-8");
            apiData.bizOwnerEmail = request.getParameter("bizOwnerMail","UTF-8");
            apiData.techOwner = request.getParameter("techOwner","UTF-8");
            apiData.techOwnerEmail = request.getParameter("techOwnerMail","UTF-8");
            apiData.visibility = request.getParameter("visibility");
            apiData.visibleRoles = request.getParameter("roles","UTF-8");
            apiData.accessControl = request.getParameter("accessControl");
            apiData.accessControlRoles = request.getParameter("accessControlRoles", "UTF-8");
            apiData.additionalProperties = request.getParameter("additionalProperties", "UTF-8");
            apiData.swagger = stringify(parse(request.getParameter("swagger", "UTF-8")));

            result = mod.updateAPIDesign(apiData);
            if (result.error==true) {
                obj = {
                    error:true,
                    message:result.message
                };
            } else {
                obj = {
                    error:false,
                    data :apiId
                }
            }
            print(obj);

        } else if (action === "validateScope") {
            mod = jagg.module("api");
            var scope = request.getParameter("scope");
            var roleName = request.getParameter("roleName");
            var data = mod.isScopeExist(scope, jagg.getUser().username, roleName);
            print(data);
        }else if (request.getMethod() == 'POST' && action === "validateAPIUpdate"){
            mod = jagg.module("api");
            var apiData = {};
            apiData.apiName = request.getParameter("name", "UTF-8");
            apiData.name = request.getParameter("name", "UTF-8");
            apiData.version = request.getParameter("version");
            if (request.getParameter("provider") == null) {
                apiData.provider = jagg.getUser().username;
            } else {
                apiData.provider = request.getParameter("provider")
            }
            var apiId = {
                apiName : request.getParameter("name", "UTF-8"),
                version : request.getParameter("version"),
                provider: apiData.provider
            };

            result = mod.isAPIUpdateValid(apiData);
            if (result.error==true) {
                obj = {
                    error:true,
                    message:result.message,
                    data :result.isValid
                };
            } else {
                obj = {
                    error:false,
                    data :result.isValid
                };
            }
            print(obj);
            return;
        } else if (request.getMethod() == 'POST' && action === 'deleteCert') {
            mod = jagg.module('api');
            var endpoint = request.getParameter('endpoint');
            var alias = request.getParameter('alias')
            result = mod.deleteCertificate(alias, endpoint);
            if (result.response == false) {
                print({error: true,
                    message: "Deleting certificate failed."
                })
            } else {
                print({
                    error: false,
                    message: {"action": "delete", "code": result.response}
                })
            }
        } else if (request.getMethod() == 'POST' && action === 'addCertificate') {
            mod = jagg.module('api');
            var alias = request.getParameter('alias');
            var ep = request.getParameter('ep');
            var certificate = request.getParameter('certificate');

            result = mod.uploadCertificate(certificate, alias, ep);

            if (result.response == false) {
                print({error: true, message: "Inserting certificate failed!"});
            } else {
                print({error: false, message: {"action": "add", "code": result.response}});
            }
        } else if (request.getMethod() == 'GET' && action === 'getAPIDefinitionVersion') {

            var apiDefinitionVersion = session.get("apiDefinitionVersion");
            session.put("apiDefinitionVersion", null);
            print(apiDefinitionVersion);
        } else if (request.getMethod() === 'POST' && action === 'validateSwagger') {
            var swagger = request.getParameter("swaggerDefinition");
            var apiDefinition = parseSwaggerDefinition(swagger);

            if (apiDefinition.swagger) {
                var swaggerDeserializationResult = parser.readWithInfo(swagger);
                var swaggerObj = swaggerDeserializationResult.getSwagger();
                var swaggerErrors = swaggerDeserializationResult.getMessages();

                //Supported swagger version check
                if (swaggerObj.swagger != supportedSwaggerVersion) {
                    print({
                        error: true,
                        message: "Unsupported swagger version provided. Please re-import with swagger " + supportedSwaggerVersion
                    });
                    return;
                }

                if (swaggerErrors.size() > 0) {
                    print({
                        error: true,
                        message: "API swagger definition is invalid. Please fix the suggested validation issues"
                    });
                    return;
                } else {
                    var swaggerJSON = JSON.parse(swagger);
                    if (swaggerJSON.paths) {
                        var swaggerPaths = swaggerJSON.paths;
                        for (var pathKey in swaggerPaths) {
                            var path = swaggerPaths[pathKey];
                            var globalParametersDefined = false;
                            var httpMethodsDefined = false;
                            for (var httpMethod in path) {
                                if (httpMethod == "parameters") {
                                    globalParametersDefined = true;
                                    continue;
                                } else if (supportedHTTPMethods.indexOf(httpMethod.toLowerCase()) === -1) {
                                    print({
                                        error: true,
                                        message: "The HTTP method '" + httpMethod + "' provided for resource '" + pathKey + "' is invalid"

                                    });
                                    return;
                                } else {
                                    httpMethodsDefined = true;
                                }
                            }
                            if (globalParametersDefined && !httpMethodsDefined) {
                                print({
                                    error: true,
                                    message: "The HTTP method '" + httpMethod + "' provided for resource '" + pathKey + "' is invalid"
                                });
                                return;
                            }
                        }
                    }
                    print({
                        error: false
                    })
                }
            } else if (apiDefinition.openapi){
                //Supported Open API Version check
                if (apiDefinition.openapi.trim() != supportedOpenAPIVersion) {
                    print({
                        error: true,
                        message: "Unsupported OpenAPI version provided. Please re-import with OpenAPI " +
                        supportedOpenAPIVersion
                    });
                    return;
                }

                if (apiDefinition.info == null || apiDefinition.paths == null) {
                    print({
                        error: true,
                        message: "Required property 'info' or 'paths' are not provided"
                    });
                    return;
                }
                print({
                    error: false
                })
            } else {
                print({error: true, message: "Invalid Open API definition provided"});
                return;
            }

        } else {
            print({
                      error:true,
                      message:msg.error.invalidAction(action)
            });
        }
    }
}());
%>
